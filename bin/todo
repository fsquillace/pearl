#!/usr/bin/python
#
# Author: Filippo Squillace <sqoox85@gmail.com>
#
# Copyright 2010
#
# This program is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License version 3, as published
# by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranties of
# MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR
# PURPOSE.  See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program.  If not, see <http://www.gnu.org/licenses/>.

'''Script for todos. It looks for Todos in all of the scripts of the framework too.

Usage:
    todo -ap/--add-path path/to/directory   Add a path to scan Todo lines
    todo -rp/--remove-path entry               Removes a path
    todo -lp/--list-path                     Lists all paths scanned for Todo lines
    todo                        Lists all Todos
    todo "A new todo"                       Add a new Todo
    todo -r/--remove                        Remove a Todo
'''
__author__ = 'Filippo Squillace'
__date__ = '25/03/2010'
__license__   = 'GPL v3'
__copyright__ = '2010'
__docformat__ = 'restructuredtext en'
__version__ = "1.1.6"


import os
import os.path
import sys 
from optparse import OptionParser
from util.logger import info, error, debug, warn
import util.io

import re
import string

import util.painter

def __print_results(entry, list_lines):
    """"""
    if len(list_lines)==0:
        return

    util.painter.red()
    print("    "+entry)
    util.painter.green()
    for (num, line) in list_lines:
        print('        '+str(num)+' '+line[:len(line)-1].strip())
        pass
    print()
    util.painter.undo()


if __name__ == "__main__":

    # To integrate todo command with remind and ranger programs, it uses
    # the related config files
    path_todos = os.environ["HOME"]+'/.reminders'
    path_dirs = os.environ["HOME"]+'/.config/ranger/bookmarks'

    # Ensure that the file already exists
    if not os.path.exists(path_todos):
        os.system('touch ' + path_todos)
    if not os.path.exists(path_dirs):
        os.system('touch ' + path_dirs)


    usage = "%prog [option] [\"todos\"]\n" + \
          "Show the todos in all of the files in the directories specified \
          by the user."

    parser = OptionParser(usage=usage)
    parser.add_option("-d","--delete-path", \
            metavar="entry",dest="entry_delete_path",help="Remove a path by the specified entry.")
    parser.add_option("-a","--add-path",\
            metavar="PATH",dest="new_path",\
            help="Add a new path.")
    parser.add_option("-l","--list-path", \
            default=False,dest="list_paths", action="store_true",\
            help="List all paths that has to be scanned for Todos.")
    
    
    parser.add_option("-r","--remove",\
            metavar="entry",dest="entry_remove_todo",\
            help="Remove a Todo by the specified entry.")

    options, args = parser.parse_args() # by default it takes sys.argv[1:]

    debug('Options: '+str(options))
    debug('Args: '+str(args))

    if options.entry_remove_todo!=None:
        counter = 0
        tmp = []
        for line in open(path_todos):
            m = re.match('REM MSG (.+)', line, flags=re.IGNORECASE)
            if m:
                if counter != int(options.entry_remove_todo):
                    tmp.append(line)
                    
                counter = counter + 1
            else:
                tmp.append(line)
        
        f = open(path_todos, 'w')
        f.writelines(tmp)

        
    elif options.entry_delete_path!=None:
        tmp = []
        for line in open(path_dirs):
            m = re.match('('+str(options.entry_delete_path)+'):(.*)', line)
            if not m:
                tmp.append(line)
        f = open(path_dirs, 'w')
        f.writelines(tmp)
        
    elif options.new_path!=None:
        abs_path = os.path.abspath(options.new_path)
        debug(abs_path)
        
        digits = [d for d in string.digits]
        for line in open(path_dirs):
            m = re.match('(\d):(.*)', line)
            if m:
                digits.remove(m.groups()[0])
        
        
        f = open(path_dirs, 'a')
        f.write('\n'+digits[0]+':'+abs_path)
        f.close()
            
    elif options.list_paths:
        for line in open(path_dirs):
            m = re.match('(\d):(.*)', line)
            if m:
                print(m.groups()[0]+') '+m.groups()[1])

    elif len(sys.argv)==2:
        f = open(path_todos, 'a')
        f.write('\nREM MSG '+sys.argv[1])
        f.close()
    elif len(sys.argv)==1:
                
        # Print todos dirs
        l_d = []
        for line in open(path_dirs):
            m = re.match('(\d):(.*)', line)
            if m:
                l_d.append(m.groups()[1])
        
        for e in l_d:
            #search_todo(e)
            dict_out = util.io.deep_search(e, 'TODO', recursive=True,\
                    case_sensitive=True, whole_words=True, pdf=False)

            util.painter.orange()
            print(e)
            util.painter.undo()
            if dict_out is not None:
                if len(dict_out)==0:
                    util.painter.cyan()
                    print('    Nothing TODO!')
                else:
                    for entry, list_lines in dict_out.items():
                        __print_results(entry, list_lines)

                
        # Prints TODOs
        todos = []
        for line in open(path_todos):
            m = re.match('REM MSG (.+)', line, flags=re.IGNORECASE)
            if m:
                todos.append(m.groups()[0])

        for ind, line in enumerate(todos):
            util.painter.green()
            util.painter.bold()
            print(( str(ind)+") "+line+"\n"))
            util.painter.undo()
            util.painter.undo()
